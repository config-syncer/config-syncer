// Code generated by protoc-gen-go.
// source: client.proto
// DO NOT EDIT!

/*
Package v1beta2 is a generated protocol buffer package.

It is generated from these files:
	client.proto

It has these top-level messages:
	ListResourceRequest
	ListResourceResponse
	DescribeResourceRequest
	DescribeResourceResponse
	UpdateResourceRequest
	ConfigMapEditRequest
	SecretEditRequest
	CopyResourceRequest
	CreateResourceRequest
	DeleteResourceRequest
	KubeResourceList
	KubeResource
	Meta
	KubeObject
	IcingaState
	App
	PodSpec
	Raw
	ConfigMap
	Job
	JobSpec
	Namespace
	Node
	Pod
	PersistentVolume
	PersistentVolumeClaim
	ObjectReference
	Service
	Secret
	ReplicationController
	ReplicaSet
	DaemonSet
	Deployment
	StatefulSet
	StorageClass
	LabelSelector
	Event
	EventSource
	Metrics
	PersistentVolumeRegisterRequest
	PersistentVolumeUnRegisterRequest
	PersistentVolumeClaimRegisterRequest
	PersistentVolumeClaimUnRegisterRequest
	Alert
	Role
	RoleBinding
	ClusterRole
	ClusterRoleBinding
	Rule
	Subject
	CronJob
	Certificate
	PersistentVolumeSource
	AWSElasticBlockStoreVolumeSource
	HostPathVolumeSource
	NFSVolumeSource
	FCVolumeSource
	FlexVolumeSource
	FlockerVolumeSource
	GCEPersistentDiskVolumeSource
	GitRepoVolumeSource
	GlusterfsVolumeSource
	RBDVolumeSource
	ISCSIVolumeSource
	AzureFileVolumeSource
	VsphereVirtualDiskVolumeSource
	QuobyteVolumeSource
	AzureDiskVolumeSource
	CinderVolumeSource
	CephFSVolumeSource
	DiskListRequest
	DiskListResponse
	DiskDescribeRequest
	DiskDescribeResponse
	DiskCreateRequest
	DiskDeleteRequest
	Disk
*/
package v1beta2

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis/google/api"
import _ "github.com/grpc-ecosystem/grpc-gateway/third_party/appscodeapis/appscode/api"
import appscode_dtypes "github.com/appscode/api/dtypes"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ListResourceRequest struct {
	Cluster        string                        `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type           string                        `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Namespace      string                        `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	IncludeMetrics bool                          `protobuf:"varint,4,opt,name=include_metrics,json=includeMetrics" json:"include_metrics,omitempty"`
	Ancestor       *ListResourceRequest_Ancestor `protobuf:"bytes,5,opt,name=ancestor" json:"ancestor,omitempty"`
	// map type is not supported by grpc-gateway as query params.
	// https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/query.go#L57
	// https://github.com/grpc-ecosystem/grpc-gateway/issues/316
	// map<string, string> label_selector = 6;
	// example label_selector=environment=production,tier=frontend
	LabelSelector string `protobuf:"bytes,7,opt,name=label_selector,json=labelSelector" json:"label_selector,omitempty"`
}

func (m *ListResourceRequest) Reset()                    { *m = ListResourceRequest{} }
func (m *ListResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ListResourceRequest) ProtoMessage()               {}
func (*ListResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ListResourceRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ListResourceRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ListResourceRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ListResourceRequest) GetIncludeMetrics() bool {
	if m != nil {
		return m.IncludeMetrics
	}
	return false
}

func (m *ListResourceRequest) GetAncestor() *ListResourceRequest_Ancestor {
	if m != nil {
		return m.Ancestor
	}
	return nil
}

func (m *ListResourceRequest) GetLabelSelector() string {
	if m != nil {
		return m.LabelSelector
	}
	return ""
}

type ListResourceRequest_Ancestor struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *ListResourceRequest_Ancestor) Reset()                    { *m = ListResourceRequest_Ancestor{} }
func (m *ListResourceRequest_Ancestor) String() string            { return proto.CompactTextString(m) }
func (*ListResourceRequest_Ancestor) ProtoMessage()               {}
func (*ListResourceRequest_Ancestor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *ListResourceRequest_Ancestor) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ListResourceRequest_Ancestor) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ListResourceResponse struct {
	Status    *appscode_dtypes.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Resources *KubeResourceList       `protobuf:"bytes,2,opt,name=resources" json:"resources,omitempty"`
}

func (m *ListResourceResponse) Reset()                    { *m = ListResourceResponse{} }
func (m *ListResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ListResourceResponse) ProtoMessage()               {}
func (*ListResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ListResourceResponse) GetStatus() *appscode_dtypes.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *ListResourceResponse) GetResources() *KubeResourceList {
	if m != nil {
		return m.Resources
	}
	return nil
}

type DescribeResourceRequest struct {
	Cluster        string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type           string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Namespace      string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Name           string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Raw            string `protobuf:"bytes,5,opt,name=raw" json:"raw,omitempty"`
	IncludeMetrics bool   `protobuf:"varint,6,opt,name=include_metrics,json=includeMetrics" json:"include_metrics,omitempty"`
}

func (m *DescribeResourceRequest) Reset()                    { *m = DescribeResourceRequest{} }
func (m *DescribeResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*DescribeResourceRequest) ProtoMessage()               {}
func (*DescribeResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DescribeResourceRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *DescribeResourceRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DescribeResourceRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DescribeResourceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DescribeResourceRequest) GetRaw() string {
	if m != nil {
		return m.Raw
	}
	return ""
}

func (m *DescribeResourceRequest) GetIncludeMetrics() bool {
	if m != nil {
		return m.IncludeMetrics
	}
	return false
}

type DescribeResourceResponse struct {
	Status   *appscode_dtypes.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Resource *KubeResource           `protobuf:"bytes,2,opt,name=resource" json:"resource,omitempty"`
}

func (m *DescribeResourceResponse) Reset()                    { *m = DescribeResourceResponse{} }
func (m *DescribeResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*DescribeResourceResponse) ProtoMessage()               {}
func (*DescribeResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DescribeResourceResponse) GetStatus() *appscode_dtypes.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DescribeResourceResponse) GetResource() *KubeResource {
	if m != nil {
		return m.Resource
	}
	return nil
}

type UpdateResourceRequest struct {
	Cluster   string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type      string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Raw       *Raw   `protobuf:"bytes,5,opt,name=raw" json:"raw,omitempty"`
}

func (m *UpdateResourceRequest) Reset()                    { *m = UpdateResourceRequest{} }
func (m *UpdateResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateResourceRequest) ProtoMessage()               {}
func (*UpdateResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UpdateResourceRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *UpdateResourceRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *UpdateResourceRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *UpdateResourceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateResourceRequest) GetRaw() *Raw {
	if m != nil {
		return m.Raw
	}
	return nil
}

type ConfigMapEditRequest struct {
	Cluster   string            `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Namespace string            `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Name      string            `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Add       map[string]string `protobuf:"bytes,4,rep,name=add" json:"add,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Update    map[string]string `protobuf:"bytes,5,rep,name=update" json:"update,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Deleted   []string          `protobuf:"bytes,6,rep,name=deleted" json:"deleted,omitempty"`
}

func (m *ConfigMapEditRequest) Reset()                    { *m = ConfigMapEditRequest{} }
func (m *ConfigMapEditRequest) String() string            { return proto.CompactTextString(m) }
func (*ConfigMapEditRequest) ProtoMessage()               {}
func (*ConfigMapEditRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *ConfigMapEditRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *ConfigMapEditRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ConfigMapEditRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ConfigMapEditRequest) GetAdd() map[string]string {
	if m != nil {
		return m.Add
	}
	return nil
}

func (m *ConfigMapEditRequest) GetUpdate() map[string]string {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *ConfigMapEditRequest) GetDeleted() []string {
	if m != nil {
		return m.Deleted
	}
	return nil
}

type SecretEditRequest struct {
	Cluster   string            `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Namespace string            `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Name      string            `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Add       map[string]string `protobuf:"bytes,4,rep,name=add" json:"add,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Update    map[string]string `protobuf:"bytes,5,rep,name=update" json:"update,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Deleted   []string          `protobuf:"bytes,6,rep,name=deleted" json:"deleted,omitempty"`
}

func (m *SecretEditRequest) Reset()                    { *m = SecretEditRequest{} }
func (m *SecretEditRequest) String() string            { return proto.CompactTextString(m) }
func (*SecretEditRequest) ProtoMessage()               {}
func (*SecretEditRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *SecretEditRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *SecretEditRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *SecretEditRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecretEditRequest) GetAdd() map[string]string {
	if m != nil {
		return m.Add
	}
	return nil
}

func (m *SecretEditRequest) GetUpdate() map[string]string {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *SecretEditRequest) GetDeleted() []string {
	if m != nil {
		return m.Deleted
	}
	return nil
}

type CopyResourceRequest struct {
	Source      *KubeObject `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Destination *KubeObject `protobuf:"bytes,2,opt,name=destination" json:"destination,omitempty"`
}

func (m *CopyResourceRequest) Reset()                    { *m = CopyResourceRequest{} }
func (m *CopyResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*CopyResourceRequest) ProtoMessage()               {}
func (*CopyResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CopyResourceRequest) GetSource() *KubeObject {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *CopyResourceRequest) GetDestination() *KubeObject {
	if m != nil {
		return m.Destination
	}
	return nil
}

type CreateResourceRequest struct {
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type    string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Name    string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	Raw     *Raw   `protobuf:"bytes,5,opt,name=raw" json:"raw,omitempty"`
}

func (m *CreateResourceRequest) Reset()                    { *m = CreateResourceRequest{} }
func (m *CreateResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateResourceRequest) ProtoMessage()               {}
func (*CreateResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CreateResourceRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *CreateResourceRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *CreateResourceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreateResourceRequest) GetRaw() *Raw {
	if m != nil {
		return m.Raw
	}
	return nil
}

type DeleteResourceRequest struct {
	Cluster   string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type      string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteResourceRequest) Reset()                    { *m = DeleteResourceRequest{} }
func (m *DeleteResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteResourceRequest) ProtoMessage()               {}
func (*DeleteResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *DeleteResourceRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *DeleteResourceRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DeleteResourceRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DeleteResourceRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type KubeResourceList struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Types that are valid to be assigned to Resource:
	//	*KubeResourceList_Apps_
	//	*KubeResourceList_ConfigMaps_
	//	*KubeResourceList_DaemonSets_
	//	*KubeResourceList_Deployments_
	//	*KubeResourceList_Jobs_
	//	*KubeResourceList_Namespaces_
	//	*KubeResourceList_Nodes_
	//	*KubeResourceList_StatefulSets_
	//	*KubeResourceList_Pods_
	//	*KubeResourceList_ReplicaSets_
	//	*KubeResourceList_Services_
	//	*KubeResourceList_Secrets_
	//	*KubeResourceList_ReplicationControllers_
	//	*KubeResourceList_StorageClasses_
	//	*KubeResourceList_PersistentVolumes_
	//	*KubeResourceList_PersistentVolumeClaims_
	//	*KubeResourceList_Alerts_
	//	*KubeResourceList_Roles_
	//	*KubeResourceList_ClusterRoles_
	//	*KubeResourceList_RoleBindings_
	//	*KubeResourceList_ClusterRoleBindings_
	//	*KubeResourceList_Certificates_
	//	*KubeResourceList_CronJobs_
	Resource isKubeResourceList_Resource `protobuf_oneof:"resource"`
}

func (m *KubeResourceList) Reset()                    { *m = KubeResourceList{} }
func (m *KubeResourceList) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList) ProtoMessage()               {}
func (*KubeResourceList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isKubeResourceList_Resource interface {
	isKubeResourceList_Resource()
}

type KubeResourceList_Apps_ struct {
	Apps *KubeResourceList_Apps `protobuf:"bytes,2,opt,name=apps,oneof"`
}
type KubeResourceList_ConfigMaps_ struct {
	ConfigMaps *KubeResourceList_ConfigMaps `protobuf:"bytes,3,opt,name=config_maps,json=configMaps,oneof"`
}
type KubeResourceList_DaemonSets_ struct {
	DaemonSets *KubeResourceList_DaemonSets `protobuf:"bytes,4,opt,name=daemon_sets,json=daemonSets,oneof"`
}
type KubeResourceList_Deployments_ struct {
	Deployments *KubeResourceList_Deployments `protobuf:"bytes,5,opt,name=deployments,oneof"`
}
type KubeResourceList_Jobs_ struct {
	Jobs *KubeResourceList_Jobs `protobuf:"bytes,6,opt,name=jobs,oneof"`
}
type KubeResourceList_Namespaces_ struct {
	Namespaces *KubeResourceList_Namespaces `protobuf:"bytes,7,opt,name=namespaces,oneof"`
}
type KubeResourceList_Nodes_ struct {
	Nodes *KubeResourceList_Nodes `protobuf:"bytes,8,opt,name=nodes,oneof"`
}
type KubeResourceList_StatefulSets_ struct {
	StatefulSets *KubeResourceList_StatefulSets `protobuf:"bytes,9,opt,name=stateful_sets,json=statefulSets,oneof"`
}
type KubeResourceList_Pods_ struct {
	Pods *KubeResourceList_Pods `protobuf:"bytes,10,opt,name=pods,oneof"`
}
type KubeResourceList_ReplicaSets_ struct {
	ReplicaSets *KubeResourceList_ReplicaSets `protobuf:"bytes,11,opt,name=replica_sets,json=replicaSets,oneof"`
}
type KubeResourceList_Services_ struct {
	Services *KubeResourceList_Services `protobuf:"bytes,12,opt,name=services,oneof"`
}
type KubeResourceList_Secrets_ struct {
	Secrets *KubeResourceList_Secrets `protobuf:"bytes,13,opt,name=secrets,oneof"`
}
type KubeResourceList_ReplicationControllers_ struct {
	ReplicationControllers *KubeResourceList_ReplicationControllers `protobuf:"bytes,14,opt,name=replication_controllers,json=replicationControllers,oneof"`
}
type KubeResourceList_StorageClasses_ struct {
	StorageClasses *KubeResourceList_StorageClasses `protobuf:"bytes,15,opt,name=storage_classes,json=storageClasses,oneof"`
}
type KubeResourceList_PersistentVolumes_ struct {
	PersistentVolumes *KubeResourceList_PersistentVolumes `protobuf:"bytes,16,opt,name=persistent_volumes,json=persistentVolumes,oneof"`
}
type KubeResourceList_PersistentVolumeClaims_ struct {
	PersistentVolumeClaims *KubeResourceList_PersistentVolumeClaims `protobuf:"bytes,17,opt,name=persistent_volume_claims,json=persistentVolumeClaims,oneof"`
}
type KubeResourceList_Alerts_ struct {
	Alerts *KubeResourceList_Alerts `protobuf:"bytes,18,opt,name=alerts,oneof"`
}
type KubeResourceList_Roles_ struct {
	Roles *KubeResourceList_Roles `protobuf:"bytes,19,opt,name=roles,oneof"`
}
type KubeResourceList_ClusterRoles_ struct {
	ClusterRoles *KubeResourceList_ClusterRoles `protobuf:"bytes,20,opt,name=cluster_roles,json=clusterRoles,oneof"`
}
type KubeResourceList_RoleBindings_ struct {
	RoleBindings *KubeResourceList_RoleBindings `protobuf:"bytes,21,opt,name=role_bindings,json=roleBindings,oneof"`
}
type KubeResourceList_ClusterRoleBindings_ struct {
	ClusterRoleBindings *KubeResourceList_ClusterRoleBindings `protobuf:"bytes,22,opt,name=cluster_role_bindings,json=clusterRoleBindings,oneof"`
}
type KubeResourceList_Certificates_ struct {
	Certificates *KubeResourceList_Certificates `protobuf:"bytes,23,opt,name=certificates,oneof"`
}
type KubeResourceList_CronJobs_ struct {
	CronJobs *KubeResourceList_CronJobs `protobuf:"bytes,24,opt,name=cron_jobs,json=cronJobs,oneof"`
}

func (*KubeResourceList_Apps_) isKubeResourceList_Resource()                   {}
func (*KubeResourceList_ConfigMaps_) isKubeResourceList_Resource()             {}
func (*KubeResourceList_DaemonSets_) isKubeResourceList_Resource()             {}
func (*KubeResourceList_Deployments_) isKubeResourceList_Resource()            {}
func (*KubeResourceList_Jobs_) isKubeResourceList_Resource()                   {}
func (*KubeResourceList_Namespaces_) isKubeResourceList_Resource()             {}
func (*KubeResourceList_Nodes_) isKubeResourceList_Resource()                  {}
func (*KubeResourceList_StatefulSets_) isKubeResourceList_Resource()           {}
func (*KubeResourceList_Pods_) isKubeResourceList_Resource()                   {}
func (*KubeResourceList_ReplicaSets_) isKubeResourceList_Resource()            {}
func (*KubeResourceList_Services_) isKubeResourceList_Resource()               {}
func (*KubeResourceList_Secrets_) isKubeResourceList_Resource()                {}
func (*KubeResourceList_ReplicationControllers_) isKubeResourceList_Resource() {}
func (*KubeResourceList_StorageClasses_) isKubeResourceList_Resource()         {}
func (*KubeResourceList_PersistentVolumes_) isKubeResourceList_Resource()      {}
func (*KubeResourceList_PersistentVolumeClaims_) isKubeResourceList_Resource() {}
func (*KubeResourceList_Alerts_) isKubeResourceList_Resource()                 {}
func (*KubeResourceList_Roles_) isKubeResourceList_Resource()                  {}
func (*KubeResourceList_ClusterRoles_) isKubeResourceList_Resource()           {}
func (*KubeResourceList_RoleBindings_) isKubeResourceList_Resource()           {}
func (*KubeResourceList_ClusterRoleBindings_) isKubeResourceList_Resource()    {}
func (*KubeResourceList_Certificates_) isKubeResourceList_Resource()           {}
func (*KubeResourceList_CronJobs_) isKubeResourceList_Resource()               {}

func (m *KubeResourceList) GetResource() isKubeResourceList_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *KubeResourceList) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *KubeResourceList) GetApps() *KubeResourceList_Apps {
	if x, ok := m.GetResource().(*KubeResourceList_Apps_); ok {
		return x.Apps
	}
	return nil
}

func (m *KubeResourceList) GetConfigMaps() *KubeResourceList_ConfigMaps {
	if x, ok := m.GetResource().(*KubeResourceList_ConfigMaps_); ok {
		return x.ConfigMaps
	}
	return nil
}

func (m *KubeResourceList) GetDaemonSets() *KubeResourceList_DaemonSets {
	if x, ok := m.GetResource().(*KubeResourceList_DaemonSets_); ok {
		return x.DaemonSets
	}
	return nil
}

func (m *KubeResourceList) GetDeployments() *KubeResourceList_Deployments {
	if x, ok := m.GetResource().(*KubeResourceList_Deployments_); ok {
		return x.Deployments
	}
	return nil
}

func (m *KubeResourceList) GetJobs() *KubeResourceList_Jobs {
	if x, ok := m.GetResource().(*KubeResourceList_Jobs_); ok {
		return x.Jobs
	}
	return nil
}

func (m *KubeResourceList) GetNamespaces() *KubeResourceList_Namespaces {
	if x, ok := m.GetResource().(*KubeResourceList_Namespaces_); ok {
		return x.Namespaces
	}
	return nil
}

func (m *KubeResourceList) GetNodes() *KubeResourceList_Nodes {
	if x, ok := m.GetResource().(*KubeResourceList_Nodes_); ok {
		return x.Nodes
	}
	return nil
}

func (m *KubeResourceList) GetStatefulSets() *KubeResourceList_StatefulSets {
	if x, ok := m.GetResource().(*KubeResourceList_StatefulSets_); ok {
		return x.StatefulSets
	}
	return nil
}

func (m *KubeResourceList) GetPods() *KubeResourceList_Pods {
	if x, ok := m.GetResource().(*KubeResourceList_Pods_); ok {
		return x.Pods
	}
	return nil
}

func (m *KubeResourceList) GetReplicaSets() *KubeResourceList_ReplicaSets {
	if x, ok := m.GetResource().(*KubeResourceList_ReplicaSets_); ok {
		return x.ReplicaSets
	}
	return nil
}

func (m *KubeResourceList) GetServices() *KubeResourceList_Services {
	if x, ok := m.GetResource().(*KubeResourceList_Services_); ok {
		return x.Services
	}
	return nil
}

func (m *KubeResourceList) GetSecrets() *KubeResourceList_Secrets {
	if x, ok := m.GetResource().(*KubeResourceList_Secrets_); ok {
		return x.Secrets
	}
	return nil
}

func (m *KubeResourceList) GetReplicationControllers() *KubeResourceList_ReplicationControllers {
	if x, ok := m.GetResource().(*KubeResourceList_ReplicationControllers_); ok {
		return x.ReplicationControllers
	}
	return nil
}

func (m *KubeResourceList) GetStorageClasses() *KubeResourceList_StorageClasses {
	if x, ok := m.GetResource().(*KubeResourceList_StorageClasses_); ok {
		return x.StorageClasses
	}
	return nil
}

func (m *KubeResourceList) GetPersistentVolumes() *KubeResourceList_PersistentVolumes {
	if x, ok := m.GetResource().(*KubeResourceList_PersistentVolumes_); ok {
		return x.PersistentVolumes
	}
	return nil
}

func (m *KubeResourceList) GetPersistentVolumeClaims() *KubeResourceList_PersistentVolumeClaims {
	if x, ok := m.GetResource().(*KubeResourceList_PersistentVolumeClaims_); ok {
		return x.PersistentVolumeClaims
	}
	return nil
}

func (m *KubeResourceList) GetAlerts() *KubeResourceList_Alerts {
	if x, ok := m.GetResource().(*KubeResourceList_Alerts_); ok {
		return x.Alerts
	}
	return nil
}

func (m *KubeResourceList) GetRoles() *KubeResourceList_Roles {
	if x, ok := m.GetResource().(*KubeResourceList_Roles_); ok {
		return x.Roles
	}
	return nil
}

func (m *KubeResourceList) GetClusterRoles() *KubeResourceList_ClusterRoles {
	if x, ok := m.GetResource().(*KubeResourceList_ClusterRoles_); ok {
		return x.ClusterRoles
	}
	return nil
}

func (m *KubeResourceList) GetRoleBindings() *KubeResourceList_RoleBindings {
	if x, ok := m.GetResource().(*KubeResourceList_RoleBindings_); ok {
		return x.RoleBindings
	}
	return nil
}

func (m *KubeResourceList) GetClusterRoleBindings() *KubeResourceList_ClusterRoleBindings {
	if x, ok := m.GetResource().(*KubeResourceList_ClusterRoleBindings_); ok {
		return x.ClusterRoleBindings
	}
	return nil
}

func (m *KubeResourceList) GetCertificates() *KubeResourceList_Certificates {
	if x, ok := m.GetResource().(*KubeResourceList_Certificates_); ok {
		return x.Certificates
	}
	return nil
}

func (m *KubeResourceList) GetCronJobs() *KubeResourceList_CronJobs {
	if x, ok := m.GetResource().(*KubeResourceList_CronJobs_); ok {
		return x.CronJobs
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*KubeResourceList) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _KubeResourceList_OneofMarshaler, _KubeResourceList_OneofUnmarshaler, _KubeResourceList_OneofSizer, []interface{}{
		(*KubeResourceList_Apps_)(nil),
		(*KubeResourceList_ConfigMaps_)(nil),
		(*KubeResourceList_DaemonSets_)(nil),
		(*KubeResourceList_Deployments_)(nil),
		(*KubeResourceList_Jobs_)(nil),
		(*KubeResourceList_Namespaces_)(nil),
		(*KubeResourceList_Nodes_)(nil),
		(*KubeResourceList_StatefulSets_)(nil),
		(*KubeResourceList_Pods_)(nil),
		(*KubeResourceList_ReplicaSets_)(nil),
		(*KubeResourceList_Services_)(nil),
		(*KubeResourceList_Secrets_)(nil),
		(*KubeResourceList_ReplicationControllers_)(nil),
		(*KubeResourceList_StorageClasses_)(nil),
		(*KubeResourceList_PersistentVolumes_)(nil),
		(*KubeResourceList_PersistentVolumeClaims_)(nil),
		(*KubeResourceList_Alerts_)(nil),
		(*KubeResourceList_Roles_)(nil),
		(*KubeResourceList_ClusterRoles_)(nil),
		(*KubeResourceList_RoleBindings_)(nil),
		(*KubeResourceList_ClusterRoleBindings_)(nil),
		(*KubeResourceList_Certificates_)(nil),
		(*KubeResourceList_CronJobs_)(nil),
	}
}

func _KubeResourceList_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*KubeResourceList)
	// resource
	switch x := m.Resource.(type) {
	case *KubeResourceList_Apps_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Apps); err != nil {
			return err
		}
	case *KubeResourceList_ConfigMaps_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfigMaps); err != nil {
			return err
		}
	case *KubeResourceList_DaemonSets_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DaemonSets); err != nil {
			return err
		}
	case *KubeResourceList_Deployments_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployments); err != nil {
			return err
		}
	case *KubeResourceList_Jobs_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Jobs); err != nil {
			return err
		}
	case *KubeResourceList_Namespaces_:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Namespaces); err != nil {
			return err
		}
	case *KubeResourceList_Nodes_:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Nodes); err != nil {
			return err
		}
	case *KubeResourceList_StatefulSets_:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatefulSets); err != nil {
			return err
		}
	case *KubeResourceList_Pods_:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pods); err != nil {
			return err
		}
	case *KubeResourceList_ReplicaSets_:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplicaSets); err != nil {
			return err
		}
	case *KubeResourceList_Services_:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Services); err != nil {
			return err
		}
	case *KubeResourceList_Secrets_:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Secrets); err != nil {
			return err
		}
	case *KubeResourceList_ReplicationControllers_:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplicationControllers); err != nil {
			return err
		}
	case *KubeResourceList_StorageClasses_:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageClasses); err != nil {
			return err
		}
	case *KubeResourceList_PersistentVolumes_:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PersistentVolumes); err != nil {
			return err
		}
	case *KubeResourceList_PersistentVolumeClaims_:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PersistentVolumeClaims); err != nil {
			return err
		}
	case *KubeResourceList_Alerts_:
		b.EncodeVarint(18<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Alerts); err != nil {
			return err
		}
	case *KubeResourceList_Roles_:
		b.EncodeVarint(19<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Roles); err != nil {
			return err
		}
	case *KubeResourceList_ClusterRoles_:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClusterRoles); err != nil {
			return err
		}
	case *KubeResourceList_RoleBindings_:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RoleBindings); err != nil {
			return err
		}
	case *KubeResourceList_ClusterRoleBindings_:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClusterRoleBindings); err != nil {
			return err
		}
	case *KubeResourceList_Certificates_:
		b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Certificates); err != nil {
			return err
		}
	case *KubeResourceList_CronJobs_:
		b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CronJobs); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("KubeResourceList.Resource has unexpected type %T", x)
	}
	return nil
}

func _KubeResourceList_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*KubeResourceList)
	switch tag {
	case 2: // resource.apps
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Apps)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Apps_{msg}
		return true, err
	case 3: // resource.config_maps
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_ConfigMaps)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_ConfigMaps_{msg}
		return true, err
	case 4: // resource.daemon_sets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_DaemonSets)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_DaemonSets_{msg}
		return true, err
	case 5: // resource.deployments
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Deployments)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Deployments_{msg}
		return true, err
	case 6: // resource.jobs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Jobs)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Jobs_{msg}
		return true, err
	case 7: // resource.namespaces
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Namespaces)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Namespaces_{msg}
		return true, err
	case 8: // resource.nodes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Nodes)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Nodes_{msg}
		return true, err
	case 9: // resource.stateful_sets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_StatefulSets)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_StatefulSets_{msg}
		return true, err
	case 10: // resource.pods
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Pods)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Pods_{msg}
		return true, err
	case 11: // resource.replica_sets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_ReplicaSets)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_ReplicaSets_{msg}
		return true, err
	case 12: // resource.services
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Services)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Services_{msg}
		return true, err
	case 13: // resource.secrets
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Secrets)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Secrets_{msg}
		return true, err
	case 14: // resource.replication_controllers
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_ReplicationControllers)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_ReplicationControllers_{msg}
		return true, err
	case 15: // resource.storage_classes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_StorageClasses)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_StorageClasses_{msg}
		return true, err
	case 16: // resource.persistent_volumes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_PersistentVolumes)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_PersistentVolumes_{msg}
		return true, err
	case 17: // resource.persistent_volume_claims
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_PersistentVolumeClaims)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_PersistentVolumeClaims_{msg}
		return true, err
	case 18: // resource.alerts
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Alerts)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Alerts_{msg}
		return true, err
	case 19: // resource.roles
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Roles)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Roles_{msg}
		return true, err
	case 20: // resource.cluster_roles
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_ClusterRoles)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_ClusterRoles_{msg}
		return true, err
	case 21: // resource.role_bindings
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_RoleBindings)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_RoleBindings_{msg}
		return true, err
	case 22: // resource.cluster_role_bindings
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_ClusterRoleBindings)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_ClusterRoleBindings_{msg}
		return true, err
	case 23: // resource.certificates
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_Certificates)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_Certificates_{msg}
		return true, err
	case 24: // resource.cron_jobs
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(KubeResourceList_CronJobs)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResourceList_CronJobs_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _KubeResourceList_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*KubeResourceList)
	// resource
	switch x := m.Resource.(type) {
	case *KubeResourceList_Apps_:
		s := proto.Size(x.Apps)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_ConfigMaps_:
		s := proto.Size(x.ConfigMaps)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_DaemonSets_:
		s := proto.Size(x.DaemonSets)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Deployments_:
		s := proto.Size(x.Deployments)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Jobs_:
		s := proto.Size(x.Jobs)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Namespaces_:
		s := proto.Size(x.Namespaces)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Nodes_:
		s := proto.Size(x.Nodes)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_StatefulSets_:
		s := proto.Size(x.StatefulSets)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Pods_:
		s := proto.Size(x.Pods)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_ReplicaSets_:
		s := proto.Size(x.ReplicaSets)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Services_:
		s := proto.Size(x.Services)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Secrets_:
		s := proto.Size(x.Secrets)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_ReplicationControllers_:
		s := proto.Size(x.ReplicationControllers)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_StorageClasses_:
		s := proto.Size(x.StorageClasses)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_PersistentVolumes_:
		s := proto.Size(x.PersistentVolumes)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_PersistentVolumeClaims_:
		s := proto.Size(x.PersistentVolumeClaims)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Alerts_:
		s := proto.Size(x.Alerts)
		n += proto.SizeVarint(18<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Roles_:
		s := proto.Size(x.Roles)
		n += proto.SizeVarint(19<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_ClusterRoles_:
		s := proto.Size(x.ClusterRoles)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_RoleBindings_:
		s := proto.Size(x.RoleBindings)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_ClusterRoleBindings_:
		s := proto.Size(x.ClusterRoleBindings)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_Certificates_:
		s := proto.Size(x.Certificates)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResourceList_CronJobs_:
		s := proto.Size(x.CronJobs)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type KubeResourceList_Apps struct {
	Items []*App `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Apps) Reset()                    { *m = KubeResourceList_Apps{} }
func (m *KubeResourceList_Apps) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Apps) ProtoMessage()               {}
func (*KubeResourceList_Apps) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *KubeResourceList_Apps) GetItems() []*App {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_ConfigMaps struct {
	Items []*ConfigMap `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_ConfigMaps) Reset()                    { *m = KubeResourceList_ConfigMaps{} }
func (m *KubeResourceList_ConfigMaps) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_ConfigMaps) ProtoMessage()               {}
func (*KubeResourceList_ConfigMaps) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 1} }

func (m *KubeResourceList_ConfigMaps) GetItems() []*ConfigMap {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_DaemonSets struct {
	Items []*DaemonSet `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_DaemonSets) Reset()                    { *m = KubeResourceList_DaemonSets{} }
func (m *KubeResourceList_DaemonSets) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_DaemonSets) ProtoMessage()               {}
func (*KubeResourceList_DaemonSets) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 2} }

func (m *KubeResourceList_DaemonSets) GetItems() []*DaemonSet {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Deployments struct {
	Items []*Deployment `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Deployments) Reset()         { *m = KubeResourceList_Deployments{} }
func (m *KubeResourceList_Deployments) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_Deployments) ProtoMessage()    {}
func (*KubeResourceList_Deployments) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 3}
}

func (m *KubeResourceList_Deployments) GetItems() []*Deployment {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Jobs struct {
	Items []*Job `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Jobs) Reset()                    { *m = KubeResourceList_Jobs{} }
func (m *KubeResourceList_Jobs) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Jobs) ProtoMessage()               {}
func (*KubeResourceList_Jobs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 4} }

func (m *KubeResourceList_Jobs) GetItems() []*Job {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Namespaces struct {
	Items []*Namespace `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Namespaces) Reset()                    { *m = KubeResourceList_Namespaces{} }
func (m *KubeResourceList_Namespaces) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Namespaces) ProtoMessage()               {}
func (*KubeResourceList_Namespaces) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 5} }

func (m *KubeResourceList_Namespaces) GetItems() []*Namespace {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Nodes struct {
	Items []*Node `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Nodes) Reset()                    { *m = KubeResourceList_Nodes{} }
func (m *KubeResourceList_Nodes) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Nodes) ProtoMessage()               {}
func (*KubeResourceList_Nodes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 6} }

func (m *KubeResourceList_Nodes) GetItems() []*Node {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_StatefulSets struct {
	Items []*StatefulSet `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_StatefulSets) Reset()         { *m = KubeResourceList_StatefulSets{} }
func (m *KubeResourceList_StatefulSets) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_StatefulSets) ProtoMessage()    {}
func (*KubeResourceList_StatefulSets) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 7}
}

func (m *KubeResourceList_StatefulSets) GetItems() []*StatefulSet {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Pods struct {
	Items []*Pod `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Pods) Reset()                    { *m = KubeResourceList_Pods{} }
func (m *KubeResourceList_Pods) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Pods) ProtoMessage()               {}
func (*KubeResourceList_Pods) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 8} }

func (m *KubeResourceList_Pods) GetItems() []*Pod {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_ReplicaSets struct {
	Items []*ReplicaSet `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_ReplicaSets) Reset()         { *m = KubeResourceList_ReplicaSets{} }
func (m *KubeResourceList_ReplicaSets) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_ReplicaSets) ProtoMessage()    {}
func (*KubeResourceList_ReplicaSets) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 9}
}

func (m *KubeResourceList_ReplicaSets) GetItems() []*ReplicaSet {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Services struct {
	Items []*Service `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Services) Reset()                    { *m = KubeResourceList_Services{} }
func (m *KubeResourceList_Services) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Services) ProtoMessage()               {}
func (*KubeResourceList_Services) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 10} }

func (m *KubeResourceList_Services) GetItems() []*Service {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Secrets struct {
	Items []*Secret `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Secrets) Reset()                    { *m = KubeResourceList_Secrets{} }
func (m *KubeResourceList_Secrets) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Secrets) ProtoMessage()               {}
func (*KubeResourceList_Secrets) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 11} }

func (m *KubeResourceList_Secrets) GetItems() []*Secret {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_ReplicationControllers struct {
	Items []*ReplicationController `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_ReplicationControllers) Reset() {
	*m = KubeResourceList_ReplicationControllers{}
}
func (m *KubeResourceList_ReplicationControllers) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_ReplicationControllers) ProtoMessage()    {}
func (*KubeResourceList_ReplicationControllers) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 12}
}

func (m *KubeResourceList_ReplicationControllers) GetItems() []*ReplicationController {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_StorageClasses struct {
	Items []*StorageClass `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_StorageClasses) Reset()         { *m = KubeResourceList_StorageClasses{} }
func (m *KubeResourceList_StorageClasses) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_StorageClasses) ProtoMessage()    {}
func (*KubeResourceList_StorageClasses) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 13}
}

func (m *KubeResourceList_StorageClasses) GetItems() []*StorageClass {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_PersistentVolumes struct {
	Items []*PersistentVolume `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_PersistentVolumes) Reset()         { *m = KubeResourceList_PersistentVolumes{} }
func (m *KubeResourceList_PersistentVolumes) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_PersistentVolumes) ProtoMessage()    {}
func (*KubeResourceList_PersistentVolumes) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 14}
}

func (m *KubeResourceList_PersistentVolumes) GetItems() []*PersistentVolume {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_PersistentVolumeClaims struct {
	Items []*PersistentVolumeClaim `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_PersistentVolumeClaims) Reset() {
	*m = KubeResourceList_PersistentVolumeClaims{}
}
func (m *KubeResourceList_PersistentVolumeClaims) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_PersistentVolumeClaims) ProtoMessage()    {}
func (*KubeResourceList_PersistentVolumeClaims) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 15}
}

func (m *KubeResourceList_PersistentVolumeClaims) GetItems() []*PersistentVolumeClaim {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Alerts struct {
	Items []*Alert `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Alerts) Reset()                    { *m = KubeResourceList_Alerts{} }
func (m *KubeResourceList_Alerts) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Alerts) ProtoMessage()               {}
func (*KubeResourceList_Alerts) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 16} }

func (m *KubeResourceList_Alerts) GetItems() []*Alert {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Roles struct {
	Items []*Role `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Roles) Reset()                    { *m = KubeResourceList_Roles{} }
func (m *KubeResourceList_Roles) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_Roles) ProtoMessage()               {}
func (*KubeResourceList_Roles) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 17} }

func (m *KubeResourceList_Roles) GetItems() []*Role {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_ClusterRoles struct {
	Items []*ClusterRole `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_ClusterRoles) Reset()         { *m = KubeResourceList_ClusterRoles{} }
func (m *KubeResourceList_ClusterRoles) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_ClusterRoles) ProtoMessage()    {}
func (*KubeResourceList_ClusterRoles) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 18}
}

func (m *KubeResourceList_ClusterRoles) GetItems() []*ClusterRole {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_RoleBindings struct {
	Items []*RoleBinding `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_RoleBindings) Reset()         { *m = KubeResourceList_RoleBindings{} }
func (m *KubeResourceList_RoleBindings) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_RoleBindings) ProtoMessage()    {}
func (*KubeResourceList_RoleBindings) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 19}
}

func (m *KubeResourceList_RoleBindings) GetItems() []*RoleBinding {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_ClusterRoleBindings struct {
	Items []*ClusterRoleBinding `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_ClusterRoleBindings) Reset()         { *m = KubeResourceList_ClusterRoleBindings{} }
func (m *KubeResourceList_ClusterRoleBindings) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_ClusterRoleBindings) ProtoMessage()    {}
func (*KubeResourceList_ClusterRoleBindings) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 20}
}

func (m *KubeResourceList_ClusterRoleBindings) GetItems() []*ClusterRoleBinding {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_Certificates struct {
	Items []*Certificate `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_Certificates) Reset()         { *m = KubeResourceList_Certificates{} }
func (m *KubeResourceList_Certificates) String() string { return proto.CompactTextString(m) }
func (*KubeResourceList_Certificates) ProtoMessage()    {}
func (*KubeResourceList_Certificates) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 21}
}

func (m *KubeResourceList_Certificates) GetItems() []*Certificate {
	if m != nil {
		return m.Items
	}
	return nil
}

type KubeResourceList_CronJobs struct {
	Items []*CronJob `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *KubeResourceList_CronJobs) Reset()                    { *m = KubeResourceList_CronJobs{} }
func (m *KubeResourceList_CronJobs) String() string            { return proto.CompactTextString(m) }
func (*KubeResourceList_CronJobs) ProtoMessage()               {}
func (*KubeResourceList_CronJobs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 22} }

func (m *KubeResourceList_CronJobs) GetItems() []*CronJob {
	if m != nil {
		return m.Items
	}
	return nil
}

// TODO: (@sadlil): when kubernetes moves to protobuf completely import fileds from there.
type KubeResource struct {
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	// Types that are valid to be assigned to Resource:
	//	*KubeResource_App
	//	*KubeResource_ConfigMap
	//	*KubeResource_DaemonSet
	//	*KubeResource_Deployment
	//	*KubeResource_Job
	//	*KubeResource_Namespace
	//	*KubeResource_Node
	//	*KubeResource_StatefulSet
	//	*KubeResource_Pod
	//	*KubeResource_ReplicaSet
	//	*KubeResource_Service
	//	*KubeResource_Secret
	//	*KubeResource_ReplicationController
	//	*KubeResource_StorageClass
	//	*KubeResource_PersistentVolume
	//	*KubeResource_PersistentVolumeClaim
	//	*KubeResource_Alert
	//	*KubeResource_Role
	//	*KubeResource_ClusterRole
	//	*KubeResource_RoleBinding
	//	*KubeResource_ClusterRoleBinding
	//	*KubeResource_Certificate
	//	*KubeResource_CronJob
	Resource isKubeResource_Resource `protobuf_oneof:"resource"`
	Events   []*Event                `protobuf:"bytes,18,rep,name=events" json:"events,omitempty"`
	Raw      *Raw                    `protobuf:"bytes,19,opt,name=raw" json:"raw,omitempty"`
}

func (m *KubeResource) Reset()                    { *m = KubeResource{} }
func (m *KubeResource) String() string            { return proto.CompactTextString(m) }
func (*KubeResource) ProtoMessage()               {}
func (*KubeResource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

type isKubeResource_Resource interface {
	isKubeResource_Resource()
}

type KubeResource_App struct {
	App *App `protobuf:"bytes,2,opt,name=app,oneof"`
}
type KubeResource_ConfigMap struct {
	ConfigMap *ConfigMap `protobuf:"bytes,3,opt,name=config_map,json=configMap,oneof"`
}
type KubeResource_DaemonSet struct {
	DaemonSet *DaemonSet `protobuf:"bytes,4,opt,name=daemon_set,json=daemonSet,oneof"`
}
type KubeResource_Deployment struct {
	Deployment *Deployment `protobuf:"bytes,5,opt,name=deployment,oneof"`
}
type KubeResource_Job struct {
	Job *Job `protobuf:"bytes,6,opt,name=job,oneof"`
}
type KubeResource_Namespace struct {
	Namespace *Namespace `protobuf:"bytes,7,opt,name=namespace,oneof"`
}
type KubeResource_Node struct {
	Node *Node `protobuf:"bytes,8,opt,name=node,oneof"`
}
type KubeResource_StatefulSet struct {
	StatefulSet *StatefulSet `protobuf:"bytes,9,opt,name=stateful_set,json=statefulSet,oneof"`
}
type KubeResource_Pod struct {
	Pod *Pod `protobuf:"bytes,10,opt,name=pod,oneof"`
}
type KubeResource_ReplicaSet struct {
	ReplicaSet *ReplicaSet `protobuf:"bytes,11,opt,name=replica_set,json=replicaSet,oneof"`
}
type KubeResource_Service struct {
	Service *Service `protobuf:"bytes,12,opt,name=service,oneof"`
}
type KubeResource_Secret struct {
	Secret *Secret `protobuf:"bytes,13,opt,name=secret,oneof"`
}
type KubeResource_ReplicationController struct {
	ReplicationController *ReplicationController `protobuf:"bytes,14,opt,name=replication_controller,json=replicationController,oneof"`
}
type KubeResource_StorageClass struct {
	StorageClass *StorageClass `protobuf:"bytes,15,opt,name=storage_class,json=storageClass,oneof"`
}
type KubeResource_PersistentVolume struct {
	PersistentVolume *PersistentVolume `protobuf:"bytes,16,opt,name=persistent_volume,json=persistentVolume,oneof"`
}
type KubeResource_PersistentVolumeClaim struct {
	PersistentVolumeClaim *PersistentVolumeClaim `protobuf:"bytes,17,opt,name=persistent_volume_claim,json=persistentVolumeClaim,oneof"`
}
type KubeResource_Alert struct {
	Alert *Alert `protobuf:"bytes,20,opt,name=alert,oneof"`
}
type KubeResource_Role struct {
	Role *Role `protobuf:"bytes,21,opt,name=role,oneof"`
}
type KubeResource_ClusterRole struct {
	ClusterRole *ClusterRole `protobuf:"bytes,22,opt,name=cluster_role,json=clusterRole,oneof"`
}
type KubeResource_RoleBinding struct {
	RoleBinding *RoleBinding `protobuf:"bytes,23,opt,name=role_binding,json=roleBinding,oneof"`
}
type KubeResource_ClusterRoleBinding struct {
	ClusterRoleBinding *ClusterRoleBinding `protobuf:"bytes,24,opt,name=cluster_role_binding,json=clusterRoleBinding,oneof"`
}
type KubeResource_Certificate struct {
	Certificate *Certificate `protobuf:"bytes,25,opt,name=certificate,oneof"`
}
type KubeResource_CronJob struct {
	CronJob *CronJob `protobuf:"bytes,26,opt,name=cron_job,json=cronJob,oneof"`
}

func (*KubeResource_App) isKubeResource_Resource()                   {}
func (*KubeResource_ConfigMap) isKubeResource_Resource()             {}
func (*KubeResource_DaemonSet) isKubeResource_Resource()             {}
func (*KubeResource_Deployment) isKubeResource_Resource()            {}
func (*KubeResource_Job) isKubeResource_Resource()                   {}
func (*KubeResource_Namespace) isKubeResource_Resource()             {}
func (*KubeResource_Node) isKubeResource_Resource()                  {}
func (*KubeResource_StatefulSet) isKubeResource_Resource()           {}
func (*KubeResource_Pod) isKubeResource_Resource()                   {}
func (*KubeResource_ReplicaSet) isKubeResource_Resource()            {}
func (*KubeResource_Service) isKubeResource_Resource()               {}
func (*KubeResource_Secret) isKubeResource_Resource()                {}
func (*KubeResource_ReplicationController) isKubeResource_Resource() {}
func (*KubeResource_StorageClass) isKubeResource_Resource()          {}
func (*KubeResource_PersistentVolume) isKubeResource_Resource()      {}
func (*KubeResource_PersistentVolumeClaim) isKubeResource_Resource() {}
func (*KubeResource_Alert) isKubeResource_Resource()                 {}
func (*KubeResource_Role) isKubeResource_Resource()                  {}
func (*KubeResource_ClusterRole) isKubeResource_Resource()           {}
func (*KubeResource_RoleBinding) isKubeResource_Resource()           {}
func (*KubeResource_ClusterRoleBinding) isKubeResource_Resource()    {}
func (*KubeResource_Certificate) isKubeResource_Resource()           {}
func (*KubeResource_CronJob) isKubeResource_Resource()               {}

func (m *KubeResource) GetResource() isKubeResource_Resource {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *KubeResource) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *KubeResource) GetApp() *App {
	if x, ok := m.GetResource().(*KubeResource_App); ok {
		return x.App
	}
	return nil
}

func (m *KubeResource) GetConfigMap() *ConfigMap {
	if x, ok := m.GetResource().(*KubeResource_ConfigMap); ok {
		return x.ConfigMap
	}
	return nil
}

func (m *KubeResource) GetDaemonSet() *DaemonSet {
	if x, ok := m.GetResource().(*KubeResource_DaemonSet); ok {
		return x.DaemonSet
	}
	return nil
}

func (m *KubeResource) GetDeployment() *Deployment {
	if x, ok := m.GetResource().(*KubeResource_Deployment); ok {
		return x.Deployment
	}
	return nil
}

func (m *KubeResource) GetJob() *Job {
	if x, ok := m.GetResource().(*KubeResource_Job); ok {
		return x.Job
	}
	return nil
}

func (m *KubeResource) GetNamespace() *Namespace {
	if x, ok := m.GetResource().(*KubeResource_Namespace); ok {
		return x.Namespace
	}
	return nil
}

func (m *KubeResource) GetNode() *Node {
	if x, ok := m.GetResource().(*KubeResource_Node); ok {
		return x.Node
	}
	return nil
}

func (m *KubeResource) GetStatefulSet() *StatefulSet {
	if x, ok := m.GetResource().(*KubeResource_StatefulSet); ok {
		return x.StatefulSet
	}
	return nil
}

func (m *KubeResource) GetPod() *Pod {
	if x, ok := m.GetResource().(*KubeResource_Pod); ok {
		return x.Pod
	}
	return nil
}

func (m *KubeResource) GetReplicaSet() *ReplicaSet {
	if x, ok := m.GetResource().(*KubeResource_ReplicaSet); ok {
		return x.ReplicaSet
	}
	return nil
}

func (m *KubeResource) GetService() *Service {
	if x, ok := m.GetResource().(*KubeResource_Service); ok {
		return x.Service
	}
	return nil
}

func (m *KubeResource) GetSecret() *Secret {
	if x, ok := m.GetResource().(*KubeResource_Secret); ok {
		return x.Secret
	}
	return nil
}

func (m *KubeResource) GetReplicationController() *ReplicationController {
	if x, ok := m.GetResource().(*KubeResource_ReplicationController); ok {
		return x.ReplicationController
	}
	return nil
}

func (m *KubeResource) GetStorageClass() *StorageClass {
	if x, ok := m.GetResource().(*KubeResource_StorageClass); ok {
		return x.StorageClass
	}
	return nil
}

func (m *KubeResource) GetPersistentVolume() *PersistentVolume {
	if x, ok := m.GetResource().(*KubeResource_PersistentVolume); ok {
		return x.PersistentVolume
	}
	return nil
}

func (m *KubeResource) GetPersistentVolumeClaim() *PersistentVolumeClaim {
	if x, ok := m.GetResource().(*KubeResource_PersistentVolumeClaim); ok {
		return x.PersistentVolumeClaim
	}
	return nil
}

func (m *KubeResource) GetAlert() *Alert {
	if x, ok := m.GetResource().(*KubeResource_Alert); ok {
		return x.Alert
	}
	return nil
}

func (m *KubeResource) GetRole() *Role {
	if x, ok := m.GetResource().(*KubeResource_Role); ok {
		return x.Role
	}
	return nil
}

func (m *KubeResource) GetClusterRole() *ClusterRole {
	if x, ok := m.GetResource().(*KubeResource_ClusterRole); ok {
		return x.ClusterRole
	}
	return nil
}

func (m *KubeResource) GetRoleBinding() *RoleBinding {
	if x, ok := m.GetResource().(*KubeResource_RoleBinding); ok {
		return x.RoleBinding
	}
	return nil
}

func (m *KubeResource) GetClusterRoleBinding() *ClusterRoleBinding {
	if x, ok := m.GetResource().(*KubeResource_ClusterRoleBinding); ok {
		return x.ClusterRoleBinding
	}
	return nil
}

func (m *KubeResource) GetCertificate() *Certificate {
	if x, ok := m.GetResource().(*KubeResource_Certificate); ok {
		return x.Certificate
	}
	return nil
}

func (m *KubeResource) GetCronJob() *CronJob {
	if x, ok := m.GetResource().(*KubeResource_CronJob); ok {
		return x.CronJob
	}
	return nil
}

func (m *KubeResource) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *KubeResource) GetRaw() *Raw {
	if m != nil {
		return m.Raw
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*KubeResource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _KubeResource_OneofMarshaler, _KubeResource_OneofUnmarshaler, _KubeResource_OneofSizer, []interface{}{
		(*KubeResource_App)(nil),
		(*KubeResource_ConfigMap)(nil),
		(*KubeResource_DaemonSet)(nil),
		(*KubeResource_Deployment)(nil),
		(*KubeResource_Job)(nil),
		(*KubeResource_Namespace)(nil),
		(*KubeResource_Node)(nil),
		(*KubeResource_StatefulSet)(nil),
		(*KubeResource_Pod)(nil),
		(*KubeResource_ReplicaSet)(nil),
		(*KubeResource_Service)(nil),
		(*KubeResource_Secret)(nil),
		(*KubeResource_ReplicationController)(nil),
		(*KubeResource_StorageClass)(nil),
		(*KubeResource_PersistentVolume)(nil),
		(*KubeResource_PersistentVolumeClaim)(nil),
		(*KubeResource_Alert)(nil),
		(*KubeResource_Role)(nil),
		(*KubeResource_ClusterRole)(nil),
		(*KubeResource_RoleBinding)(nil),
		(*KubeResource_ClusterRoleBinding)(nil),
		(*KubeResource_Certificate)(nil),
		(*KubeResource_CronJob)(nil),
	}
}

func _KubeResource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*KubeResource)
	// resource
	switch x := m.Resource.(type) {
	case *KubeResource_App:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.App); err != nil {
			return err
		}
	case *KubeResource_ConfigMap:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ConfigMap); err != nil {
			return err
		}
	case *KubeResource_DaemonSet:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DaemonSet); err != nil {
			return err
		}
	case *KubeResource_Deployment:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Deployment); err != nil {
			return err
		}
	case *KubeResource_Job:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Job); err != nil {
			return err
		}
	case *KubeResource_Namespace:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Namespace); err != nil {
			return err
		}
	case *KubeResource_Node:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Node); err != nil {
			return err
		}
	case *KubeResource_StatefulSet:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatefulSet); err != nil {
			return err
		}
	case *KubeResource_Pod:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pod); err != nil {
			return err
		}
	case *KubeResource_ReplicaSet:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplicaSet); err != nil {
			return err
		}
	case *KubeResource_Service:
		b.EncodeVarint(12<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Service); err != nil {
			return err
		}
	case *KubeResource_Secret:
		b.EncodeVarint(13<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Secret); err != nil {
			return err
		}
	case *KubeResource_ReplicationController:
		b.EncodeVarint(14<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReplicationController); err != nil {
			return err
		}
	case *KubeResource_StorageClass:
		b.EncodeVarint(15<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StorageClass); err != nil {
			return err
		}
	case *KubeResource_PersistentVolume:
		b.EncodeVarint(16<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PersistentVolume); err != nil {
			return err
		}
	case *KubeResource_PersistentVolumeClaim:
		b.EncodeVarint(17<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PersistentVolumeClaim); err != nil {
			return err
		}
	case *KubeResource_Alert:
		b.EncodeVarint(20<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Alert); err != nil {
			return err
		}
	case *KubeResource_Role:
		b.EncodeVarint(21<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Role); err != nil {
			return err
		}
	case *KubeResource_ClusterRole:
		b.EncodeVarint(22<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClusterRole); err != nil {
			return err
		}
	case *KubeResource_RoleBinding:
		b.EncodeVarint(23<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RoleBinding); err != nil {
			return err
		}
	case *KubeResource_ClusterRoleBinding:
		b.EncodeVarint(24<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ClusterRoleBinding); err != nil {
			return err
		}
	case *KubeResource_Certificate:
		b.EncodeVarint(25<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Certificate); err != nil {
			return err
		}
	case *KubeResource_CronJob:
		b.EncodeVarint(26<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.CronJob); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("KubeResource.Resource has unexpected type %T", x)
	}
	return nil
}

func _KubeResource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*KubeResource)
	switch tag {
	case 2: // resource.app
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(App)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_App{msg}
		return true, err
	case 3: // resource.config_map
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ConfigMap)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_ConfigMap{msg}
		return true, err
	case 4: // resource.daemon_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DaemonSet)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_DaemonSet{msg}
		return true, err
	case 5: // resource.deployment
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Deployment)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Deployment{msg}
		return true, err
	case 6: // resource.job
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Job)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Job{msg}
		return true, err
	case 7: // resource.namespace
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Namespace)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Namespace{msg}
		return true, err
	case 8: // resource.node
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Node)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Node{msg}
		return true, err
	case 9: // resource.stateful_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatefulSet)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_StatefulSet{msg}
		return true, err
	case 10: // resource.pod
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Pod)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Pod{msg}
		return true, err
	case 11: // resource.replica_set
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReplicaSet)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_ReplicaSet{msg}
		return true, err
	case 12: // resource.service
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Service)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Service{msg}
		return true, err
	case 13: // resource.secret
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Secret)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Secret{msg}
		return true, err
	case 14: // resource.replication_controller
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ReplicationController)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_ReplicationController{msg}
		return true, err
	case 15: // resource.storage_class
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StorageClass)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_StorageClass{msg}
		return true, err
	case 16: // resource.persistent_volume
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PersistentVolume)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_PersistentVolume{msg}
		return true, err
	case 17: // resource.persistent_volume_claim
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PersistentVolumeClaim)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_PersistentVolumeClaim{msg}
		return true, err
	case 20: // resource.alert
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Alert)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Alert{msg}
		return true, err
	case 21: // resource.role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Role)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Role{msg}
		return true, err
	case 22: // resource.cluster_role
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClusterRole)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_ClusterRole{msg}
		return true, err
	case 23: // resource.role_binding
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RoleBinding)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_RoleBinding{msg}
		return true, err
	case 24: // resource.cluster_role_binding
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ClusterRoleBinding)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_ClusterRoleBinding{msg}
		return true, err
	case 25: // resource.certificate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Certificate)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_Certificate{msg}
		return true, err
	case 26: // resource.cron_job
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CronJob)
		err := b.DecodeMessage(msg)
		m.Resource = &KubeResource_CronJob{msg}
		return true, err
	default:
		return false, nil
	}
}

func _KubeResource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*KubeResource)
	// resource
	switch x := m.Resource.(type) {
	case *KubeResource_App:
		s := proto.Size(x.App)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_ConfigMap:
		s := proto.Size(x.ConfigMap)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_DaemonSet:
		s := proto.Size(x.DaemonSet)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Deployment:
		s := proto.Size(x.Deployment)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Job:
		s := proto.Size(x.Job)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Namespace:
		s := proto.Size(x.Namespace)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Node:
		s := proto.Size(x.Node)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_StatefulSet:
		s := proto.Size(x.StatefulSet)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Pod:
		s := proto.Size(x.Pod)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_ReplicaSet:
		s := proto.Size(x.ReplicaSet)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Service:
		s := proto.Size(x.Service)
		n += proto.SizeVarint(12<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Secret:
		s := proto.Size(x.Secret)
		n += proto.SizeVarint(13<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_ReplicationController:
		s := proto.Size(x.ReplicationController)
		n += proto.SizeVarint(14<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_StorageClass:
		s := proto.Size(x.StorageClass)
		n += proto.SizeVarint(15<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_PersistentVolume:
		s := proto.Size(x.PersistentVolume)
		n += proto.SizeVarint(16<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_PersistentVolumeClaim:
		s := proto.Size(x.PersistentVolumeClaim)
		n += proto.SizeVarint(17<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Alert:
		s := proto.Size(x.Alert)
		n += proto.SizeVarint(20<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Role:
		s := proto.Size(x.Role)
		n += proto.SizeVarint(21<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_ClusterRole:
		s := proto.Size(x.ClusterRole)
		n += proto.SizeVarint(22<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_RoleBinding:
		s := proto.Size(x.RoleBinding)
		n += proto.SizeVarint(23<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_ClusterRoleBinding:
		s := proto.Size(x.ClusterRoleBinding)
		n += proto.SizeVarint(24<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_Certificate:
		s := proto.Size(x.Certificate)
		n += proto.SizeVarint(25<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *KubeResource_CronJob:
		s := proto.Size(x.CronJob)
		n += proto.SizeVarint(26<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Meta struct {
	Name            string            `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Namespace       string            `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	SelfLinks       string            `protobuf:"bytes,3,opt,name=self_links,json=selfLinks" json:"self_links,omitempty"`
	ResourceVersion string            `protobuf:"bytes,4,opt,name=resource_version,json=resourceVersion" json:"resource_version,omitempty"`
	CreatedAt       int64             `protobuf:"varint,5,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	Generation      int64             `protobuf:"varint,6,opt,name=generation" json:"generation,omitempty"`
	Labels          map[string]string `protobuf:"bytes,7,rep,name=labels" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Annotations     map[string]string `protobuf:"bytes,8,rep,name=annotations" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Meta) Reset()                    { *m = Meta{} }
func (m *Meta) String() string            { return proto.CompactTextString(m) }
func (*Meta) ProtoMessage()               {}
func (*Meta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Meta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Meta) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Meta) GetSelfLinks() string {
	if m != nil {
		return m.SelfLinks
	}
	return ""
}

func (m *Meta) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

func (m *Meta) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Meta) GetGeneration() int64 {
	if m != nil {
		return m.Generation
	}
	return 0
}

func (m *Meta) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Meta) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

type KubeObject struct {
	Cluster   string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type      string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Name      string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
}

func (m *KubeObject) Reset()                    { *m = KubeObject{} }
func (m *KubeObject) String() string            { return proto.CompactTextString(m) }
func (*KubeObject) ProtoMessage()               {}
func (*KubeObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *KubeObject) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *KubeObject) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *KubeObject) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *KubeObject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type IcingaState struct {
	OK       int32 `protobuf:"varint,1,opt,name=OK" json:"OK,omitempty"`
	Warning  int32 `protobuf:"varint,2,opt,name=Warning" json:"Warning,omitempty"`
	Critical int32 `protobuf:"varint,3,opt,name=Critical" json:"Critical,omitempty"`
	Unknown  int32 `protobuf:"varint,4,opt,name=Unknown" json:"Unknown,omitempty"`
}

func (m *IcingaState) Reset()                    { *m = IcingaState{} }
func (m *IcingaState) String() string            { return proto.CompactTextString(m) }
func (*IcingaState) ProtoMessage()               {}
func (*IcingaState) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *IcingaState) GetOK() int32 {
	if m != nil {
		return m.OK
	}
	return 0
}

func (m *IcingaState) GetWarning() int32 {
	if m != nil {
		return m.Warning
	}
	return 0
}

func (m *IcingaState) GetCritical() int32 {
	if m != nil {
		return m.Critical
	}
	return 0
}

func (m *IcingaState) GetUnknown() int32 {
	if m != nil {
		return m.Unknown
	}
	return 0
}

type App struct {
	Cluster     string            `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Type        string            `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	Namespace   string            `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
	Name        string            `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	App         *Service          `protobuf:"bytes,5,opt,name=app" json:"app,omitempty"`
	Links       map[string]string `protobuf:"bytes,6,rep,name=links" json:"links,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	CreatedAt   int64             `protobuf:"varint,7,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	ClusterIp   string            `protobuf:"bytes,8,opt,name=cluster_ip,json=clusterIp" json:"cluster_ip,omitempty"`
	IcingaState *IcingaState      `protobuf:"bytes,9,opt,name=icinga_state,json=icingaState" json:"icinga_state,omitempty"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *App) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *App) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *App) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *App) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *App) GetApp() *Service {
	if m != nil {
		return m.App
	}
	return nil
}

func (m *App) GetLinks() map[string]string {
	if m != nil {
		return m.Links
	}
	return nil
}

func (m *App) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *App) GetClusterIp() string {
	if m != nil {
		return m.ClusterIp
	}
	return ""
}

func (m *App) GetIcingaState() *IcingaState {
	if m != nil {
		return m.IcingaState
	}
	return nil
}

type PodSpec struct {
	Volumes            []*PodSpec_Volume    `protobuf:"bytes,1,rep,name=volumes" json:"volumes,omitempty"`
	Containers         []*PodSpec_Container `protobuf:"bytes,2,rep,name=containers" json:"containers,omitempty"`
	NodeSelectors      map[string]string    `protobuf:"bytes,3,rep,name=node_selectors,json=nodeSelectors" json:"node_selectors,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ServiceAccountName string               `protobuf:"bytes,4,opt,name=service_account_name,json=serviceAccountName" json:"service_account_name,omitempty"`
	NodeName           string               `protobuf:"bytes,5,opt,name=node_name,json=nodeName" json:"node_name,omitempty"`
	ImagePullSecrets   []string             `protobuf:"bytes,6,rep,name=image_pull_secrets,json=imagePullSecrets" json:"image_pull_secrets,omitempty"`
}

func (m *PodSpec) Reset()                    { *m = PodSpec{} }
func (m *PodSpec) String() string            { return proto.CompactTextString(m) }
func (*PodSpec) ProtoMessage()               {}
func (*PodSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *PodSpec) GetVolumes() []*PodSpec_Volume {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *PodSpec) GetContainers() []*PodSpec_Container {
	if m != nil {
		return m.Containers
	}
	return nil
}

func (m *PodSpec) GetNodeSelectors() map[string]string {
	if m != nil {
		return m.NodeSelectors
	}
	return nil
}

func (m *PodSpec) GetServiceAccountName() string {
	if m != nil {
		return m.ServiceAccountName
	}
	return ""
}

func (m *PodSpec) GetNodeName() string {
	if m != nil {
		return m.NodeName
	}
	return ""
}

func (m *PodSpec) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

type PodSpec_Container struct {
	Name         string                           `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Image        string                           `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	Commands     []string                         `protobuf:"bytes,3,rep,name=commands" json:"commands,omitempty"`
	VolumeMounts []*PodSpec_Container_VolumeMount `protobuf:"bytes,4,rep,name=volume_mounts,json=volumeMounts" json:"volume_mounts,omitempty"`
}

func (m *PodSpec_Container) Reset()                    { *m = PodSpec_Container{} }
func (m *PodSpec_Container) String() string            { return proto.CompactTextString(m) }
func (*PodSpec_Container) ProtoMessage()               {}
func (*PodSpec_Container) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 1} }

func (m *PodSpec_Container) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PodSpec_Container) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *PodSpec_Container) GetCommands() []string {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *PodSpec_Container) GetVolumeMounts() []*PodSpec_Container_VolumeMount {
	if m != nil {
		return m.VolumeMounts
	}
	return nil
}

type PodSpec_Container_VolumeMount struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	ReadOnly  bool   `protobuf:"varint,2,opt,name=read_only,json=readOnly" json:"read_only,omitempty"`
	MountPath string `protobuf:"bytes,3,opt,name=mount_path,json=mountPath" json:"mount_path,omitempty"`
}

func (m *PodSpec_Container_VolumeMount) Reset()         { *m = PodSpec_Container_VolumeMount{} }
func (m *PodSpec_Container_VolumeMount) String() string { return proto.CompactTextString(m) }
func (*PodSpec_Container_VolumeMount) ProtoMessage()    {}
func (*PodSpec_Container_VolumeMount) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 1, 0}
}

func (m *PodSpec_Container_VolumeMount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PodSpec_Container_VolumeMount) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *PodSpec_Container_VolumeMount) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

type PodSpec_Volume struct {
	Name     string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	HostPath string `protobuf:"bytes,2,opt,name=host_path,json=hostPath" json:"host_path,omitempty"`
}

func (m *PodSpec_Volume) Reset()                    { *m = PodSpec_Volume{} }
func (m *PodSpec_Volume) String() string            { return proto.CompactTextString(m) }
func (*PodSpec_Volume) ProtoMessage()               {}
func (*PodSpec_Volume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 2} }

func (m *PodSpec_Volume) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PodSpec_Volume) GetHostPath() string {
	if m != nil {
		return m.HostPath
	}
	return ""
}

type Raw struct {
	Format string `protobuf:"bytes,1,opt,name=format" json:"format,omitempty"`
	Data   string `protobuf:"bytes,2,opt,name=data" json:"data,omitempty"`
}

func (m *Raw) Reset()                    { *m = Raw{} }
func (m *Raw) String() string            { return proto.CompactTextString(m) }
func (*Raw) ProtoMessage()               {}
func (*Raw) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *Raw) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *Raw) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type ConfigMap struct {
	Meta *Meta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Data map[string]string `protobuf:"bytes,2,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *ConfigMap) Reset()                    { *m = ConfigMap{} }
func (m *ConfigMap) String() string            { return proto.CompactTextString(m) }
func (*ConfigMap) ProtoMessage()               {}
func (*ConfigMap) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ConfigMap) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ConfigMap) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

type Job struct {
	Meta   *Meta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string      `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Space  *JobSpec    `protobuf:"bytes,3,opt,name=space" json:"space,omitempty"`
	Status *Job_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *Job) Reset()                    { *m = Job{} }
func (m *Job) String() string            { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()               {}
func (*Job) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Job) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Job) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *Job) GetSpace() *JobSpec {
	if m != nil {
		return m.Space
	}
	return nil
}

func (m *Job) GetStatus() *Job_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Job_Status struct {
	StartTime      int64 `protobuf:"varint,1,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	CompletionTime int64 `protobuf:"varint,2,opt,name=completion_time,json=completionTime" json:"completion_time,omitempty"`
	Active         int32 `protobuf:"varint,3,opt,name=active" json:"active,omitempty"`
	Succeeded      int32 `protobuf:"varint,4,opt,name=succeeded" json:"succeeded,omitempty"`
	Failed         int32 `protobuf:"varint,5,opt,name=failed" json:"failed,omitempty"`
}

func (m *Job_Status) Reset()                    { *m = Job_Status{} }
func (m *Job_Status) String() string            { return proto.CompactTextString(m) }
func (*Job_Status) ProtoMessage()               {}
func (*Job_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19, 0} }

func (m *Job_Status) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Job_Status) GetCompletionTime() int64 {
	if m != nil {
		return m.CompletionTime
	}
	return 0
}

func (m *Job_Status) GetActive() int32 {
	if m != nil {
		return m.Active
	}
	return 0
}

func (m *Job_Status) GetSucceeded() int32 {
	if m != nil {
		return m.Succeeded
	}
	return 0
}

func (m *Job_Status) GetFailed() int32 {
	if m != nil {
		return m.Failed
	}
	return 0
}

type JobSpec struct {
	Parallelism int32    `protobuf:"varint,1,opt,name=parallelism" json:"parallelism,omitempty"`
	Completions int32    `protobuf:"varint,2,opt,name=completions" json:"completions,omitempty"`
	Template    *PodSpec `protobuf:"bytes,3,opt,name=template" json:"template,omitempty"`
}

func (m *JobSpec) Reset()                    { *m = JobSpec{} }
func (m *JobSpec) String() string            { return proto.CompactTextString(m) }
func (*JobSpec) ProtoMessage()               {}
func (*JobSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *JobSpec) GetParallelism() int32 {
	if m != nil {
		return m.Parallelism
	}
	return 0
}

func (m *JobSpec) GetCompletions() int32 {
	if m != nil {
		return m.Completions
	}
	return 0
}

func (m *JobSpec) GetTemplate() *PodSpec {
	if m != nil {
		return m.Template
	}
	return nil
}

type Namespace struct {
	Meta   *Meta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Status *Namespace_Status `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
}

func (m *Namespace) Reset()                    { *m = Namespace{} }
func (m *Namespace) String() string            { return proto.CompactTextString(m) }
func (*Namespace) ProtoMessage()               {}
func (*Namespace) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Namespace) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Namespace) GetStatus() *Namespace_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Namespace_Status struct {
	Phase string `protobuf:"bytes,1,opt,name=phase" json:"phase,omitempty"`
}

func (m *Namespace_Status) Reset()                    { *m = Namespace_Status{} }
func (m *Namespace_Status) String() string            { return proto.CompactTextString(m) }
func (*Namespace_Status) ProtoMessage()               {}
func (*Namespace_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21, 0} }

func (m *Namespace_Status) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

type Node struct {
	Meta     *Meta        `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec     *Node_Spec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	IsMaster bool         `protobuf:"varint,3,opt,name=is_master,json=isMaster" json:"is_master,omitempty"`
	Status   *Node_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
	Metrics  *Metrics     `protobuf:"bytes,5,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *Node) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Node) GetSpec() *Node_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Node) GetIsMaster() bool {
	if m != nil {
		return m.IsMaster
	}
	return false
}

func (m *Node) GetStatus() *Node_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Node) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Node_Spec struct {
	ExternalId    string `protobuf:"bytes,1,opt,name=external_id,json=externalId" json:"external_id,omitempty"`
	ProviderId    string `protobuf:"bytes,2,opt,name=provider_id,json=providerId" json:"provider_id,omitempty"`
	Unschedulable bool   `protobuf:"varint,3,opt,name=unschedulable" json:"unschedulable,omitempty"`
}

func (m *Node_Spec) Reset()                    { *m = Node_Spec{} }
func (m *Node_Spec) String() string            { return proto.CompactTextString(m) }
func (*Node_Spec) ProtoMessage()               {}
func (*Node_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 0} }

func (m *Node_Spec) GetExternalId() string {
	if m != nil {
		return m.ExternalId
	}
	return ""
}

func (m *Node_Spec) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *Node_Spec) GetUnschedulable() bool {
	if m != nil {
		return m.Unschedulable
	}
	return false
}

type Node_Status struct {
	Capacity *Node_Status_Capacity `protobuf:"bytes,1,opt,name=capacity" json:"capacity,omitempty"`
	Phase    string                `protobuf:"bytes,2,opt,name=phase" json:"phase,omitempty"`
	NodeInfo *Node_Status_NodeInfo `protobuf:"bytes,3,opt,name=node_info,json=nodeInfo" json:"node_info,omitempty"`
}

func (m *Node_Status) Reset()                    { *m = Node_Status{} }
func (m *Node_Status) String() string            { return proto.CompactTextString(m) }
func (*Node_Status) ProtoMessage()               {}
func (*Node_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 1} }

func (m *Node_Status) GetCapacity() *Node_Status_Capacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *Node_Status) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *Node_Status) GetNodeInfo() *Node_Status_NodeInfo {
	if m != nil {
		return m.NodeInfo
	}
	return nil
}

type Node_Status_Capacity struct {
	Cpu    int64 `protobuf:"varint,1,opt,name=cpu" json:"cpu,omitempty"`
	Memory int64 `protobuf:"varint,2,opt,name=memory" json:"memory,omitempty"`
	Pods   int64 `protobuf:"varint,3,opt,name=pods" json:"pods,omitempty"`
}

func (m *Node_Status_Capacity) Reset()                    { *m = Node_Status_Capacity{} }
func (m *Node_Status_Capacity) String() string            { return proto.CompactTextString(m) }
func (*Node_Status_Capacity) ProtoMessage()               {}
func (*Node_Status_Capacity) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 1, 0} }

func (m *Node_Status_Capacity) GetCpu() int64 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *Node_Status_Capacity) GetMemory() int64 {
	if m != nil {
		return m.Memory
	}
	return 0
}

func (m *Node_Status_Capacity) GetPods() int64 {
	if m != nil {
		return m.Pods
	}
	return 0
}

type Node_Status_NodeInfo struct {
	KernelVersion           string `protobuf:"bytes,1,opt,name=kernel_version,json=kernelVersion" json:"kernel_version,omitempty"`
	OsImage                 string `protobuf:"bytes,2,opt,name=os_image,json=osImage" json:"os_image,omitempty"`
	ContainerRuntimeVersion string `protobuf:"bytes,3,opt,name=container_runtime_version,json=containerRuntimeVersion" json:"container_runtime_version,omitempty"`
	KubeletVersion          string `protobuf:"bytes,4,opt,name=kubelet_version,json=kubeletVersion" json:"kubelet_version,omitempty"`
	KubeProxyVersion        string `protobuf:"bytes,5,opt,name=kube_proxy_version,json=kubeProxyVersion" json:"kube_proxy_version,omitempty"`
}

func (m *Node_Status_NodeInfo) Reset()                    { *m = Node_Status_NodeInfo{} }
func (m *Node_Status_NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*Node_Status_NodeInfo) ProtoMessage()               {}
func (*Node_Status_NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22, 1, 1} }

func (m *Node_Status_NodeInfo) GetKernelVersion() string {
	if m != nil {
		return m.KernelVersion
	}
	return ""
}

func (m *Node_Status_NodeInfo) GetOsImage() string {
	if m != nil {
		return m.OsImage
	}
	return ""
}

func (m *Node_Status_NodeInfo) GetContainerRuntimeVersion() string {
	if m != nil {
		return m.ContainerRuntimeVersion
	}
	return ""
}

func (m *Node_Status_NodeInfo) GetKubeletVersion() string {
	if m != nil {
		return m.KubeletVersion
	}
	return ""
}

func (m *Node_Status_NodeInfo) GetKubeProxyVersion() string {
	if m != nil {
		return m.KubeProxyVersion
	}
	return ""
}

type Pod struct {
	Meta    *Meta       `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App     string      `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec    *PodSpec    `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status  *Pod_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
	Metrics *Metrics    `protobuf:"bytes,5,opt,name=metrics" json:"metrics,omitempty"`
}

func (m *Pod) Reset()                    { *m = Pod{} }
func (m *Pod) String() string            { return proto.CompactTextString(m) }
func (*Pod) ProtoMessage()               {}
func (*Pod) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Pod) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Pod) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *Pod) GetSpec() *PodSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Pod) GetStatus() *Pod_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *Pod) GetMetrics() *Metrics {
	if m != nil {
		return m.Metrics
	}
	return nil
}

type Pod_Status struct {
	Phase   string `protobuf:"bytes,1,opt,name=phase" json:"phase,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Reason  string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
	HostIP  string `protobuf:"bytes,4,opt,name=hostIP" json:"hostIP,omitempty"`
	PodIP   string `protobuf:"bytes,5,opt,name=podIP" json:"podIP,omitempty"`
}

func (m *Pod_Status) Reset()                    { *m = Pod_Status{} }
func (m *Pod_Status) String() string            { return proto.CompactTextString(m) }
func (*Pod_Status) ProtoMessage()               {}
func (*Pod_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23, 0} }

func (m *Pod_Status) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *Pod_Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Pod_Status) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Pod_Status) GetHostIP() string {
	if m != nil {
		return m.HostIP
	}
	return ""
}

func (m *Pod_Status) GetPodIP() string {
	if m != nil {
		return m.PodIP
	}
	return ""
}

type PersistentVolume struct {
	Meta   *Meta                                    `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *PersistentVolume_PersistentVolumeSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *PersistentVolume_PersistentVolumeStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *PersistentVolume) Reset()                    { *m = PersistentVolume{} }
func (m *PersistentVolume) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolume) ProtoMessage()               {}
func (*PersistentVolume) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *PersistentVolume) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PersistentVolume) GetSpec() *PersistentVolume_PersistentVolumeSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PersistentVolume) GetStatus() *PersistentVolume_PersistentVolumeStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type PersistentVolume_PersistentVolumeSpec struct {
	Capacity                      map[string]string       `protobuf:"bytes,1,rep,name=capacity" json:"capacity,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AccessModes                   []string                `protobuf:"bytes,2,rep,name=access_modes,json=accessModes" json:"access_modes,omitempty"`
	PersistentVolumeReclaimPolicy string                  `protobuf:"bytes,3,opt,name=persistent_volume_reclaim_policy,json=persistentVolumeReclaimPolicy" json:"persistent_volume_reclaim_policy,omitempty"`
	ClaimRef                      *ObjectReference        `protobuf:"bytes,4,opt,name=claim_ref,json=claimRef" json:"claim_ref,omitempty"`
	PersistentVolumeSource        *PersistentVolumeSource `protobuf:"bytes,5,opt,name=persistent_volume_source,json=persistentVolumeSource" json:"persistent_volume_source,omitempty"`
}

func (m *PersistentVolume_PersistentVolumeSpec) Reset()         { *m = PersistentVolume_PersistentVolumeSpec{} }
func (m *PersistentVolume_PersistentVolumeSpec) String() string { return proto.CompactTextString(m) }
func (*PersistentVolume_PersistentVolumeSpec) ProtoMessage()    {}
func (*PersistentVolume_PersistentVolumeSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{24, 0}
}

func (m *PersistentVolume_PersistentVolumeSpec) GetCapacity() map[string]string {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *PersistentVolume_PersistentVolumeSpec) GetAccessModes() []string {
	if m != nil {
		return m.AccessModes
	}
	return nil
}

func (m *PersistentVolume_PersistentVolumeSpec) GetPersistentVolumeReclaimPolicy() string {
	if m != nil {
		return m.PersistentVolumeReclaimPolicy
	}
	return ""
}

func (m *PersistentVolume_PersistentVolumeSpec) GetClaimRef() *ObjectReference {
	if m != nil {
		return m.ClaimRef
	}
	return nil
}

func (m *PersistentVolume_PersistentVolumeSpec) GetPersistentVolumeSource() *PersistentVolumeSource {
	if m != nil {
		return m.PersistentVolumeSource
	}
	return nil
}

type PersistentVolume_PersistentVolumeStatus struct {
	Phase   string `protobuf:"bytes,1,opt,name=phase" json:"phase,omitempty"`
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	Reason  string `protobuf:"bytes,3,opt,name=reason" json:"reason,omitempty"`
}

func (m *PersistentVolume_PersistentVolumeStatus) Reset() {
	*m = PersistentVolume_PersistentVolumeStatus{}
}
func (m *PersistentVolume_PersistentVolumeStatus) String() string { return proto.CompactTextString(m) }
func (*PersistentVolume_PersistentVolumeStatus) ProtoMessage()    {}
func (*PersistentVolume_PersistentVolumeStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{24, 1}
}

func (m *PersistentVolume_PersistentVolumeStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *PersistentVolume_PersistentVolumeStatus) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *PersistentVolume_PersistentVolumeStatus) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type PersistentVolumeClaim struct {
	Meta   *Meta                                              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *PersistentVolumeClaim_PersistentVolumeClaimSpec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *PersistentVolumeClaim_PersistentVolumeClaimStatus `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *PersistentVolumeClaim) Reset()                    { *m = PersistentVolumeClaim{} }
func (m *PersistentVolumeClaim) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolumeClaim) ProtoMessage()               {}
func (*PersistentVolumeClaim) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *PersistentVolumeClaim) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *PersistentVolumeClaim) GetSpec() *PersistentVolumeClaim_PersistentVolumeClaimSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *PersistentVolumeClaim) GetStatus() *PersistentVolumeClaim_PersistentVolumeClaimStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type PersistentVolumeClaim_PersistentVolumeClaimSpec struct {
	AccessModes []string                                                              `protobuf:"bytes,1,rep,name=access_modes,json=accessModes" json:"access_modes,omitempty"`
	Resources   *PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements `protobuf:"bytes,2,opt,name=resources" json:"resources,omitempty"`
	VolumeName  string                                                                `protobuf:"bytes,3,opt,name=volume_name,json=volumeName" json:"volume_name,omitempty"`
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec) Reset() {
	*m = PersistentVolumeClaim_PersistentVolumeClaimSpec{}
}
func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec) String() string {
	return proto.CompactTextString(m)
}
func (*PersistentVolumeClaim_PersistentVolumeClaimSpec) ProtoMessage() {}
func (*PersistentVolumeClaim_PersistentVolumeClaimSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{25, 0}
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec) GetAccessModes() []string {
	if m != nil {
		return m.AccessModes
	}
	return nil
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec) GetResources() *PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec) GetVolumeName() string {
	if m != nil {
		return m.VolumeName
	}
	return ""
}

type PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements struct {
	Limits   map[string]string `protobuf:"bytes,1,rep,name=limits" json:"limits,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Requests map[string]string `protobuf:"bytes,2,rep,name=requests" json:"requests,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements) Reset() {
	*m = PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements{}
}
func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements) String() string {
	return proto.CompactTextString(m)
}
func (*PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements) ProtoMessage() {}
func (*PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{25, 0, 0}
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements) GetLimits() map[string]string {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements) GetRequests() map[string]string {
	if m != nil {
		return m.Requests
	}
	return nil
}

type PersistentVolumeClaim_PersistentVolumeClaimStatus struct {
	Phase       string            `protobuf:"bytes,1,opt,name=phase" json:"phase,omitempty"`
	AccessModes []string          `protobuf:"bytes,2,rep,name=access_modes,json=accessModes" json:"access_modes,omitempty"`
	Capacity    map[string]string `protobuf:"bytes,3,rep,name=capacity" json:"capacity,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimStatus) Reset() {
	*m = PersistentVolumeClaim_PersistentVolumeClaimStatus{}
}
func (m *PersistentVolumeClaim_PersistentVolumeClaimStatus) String() string {
	return proto.CompactTextString(m)
}
func (*PersistentVolumeClaim_PersistentVolumeClaimStatus) ProtoMessage() {}
func (*PersistentVolumeClaim_PersistentVolumeClaimStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{25, 1}
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimStatus) GetPhase() string {
	if m != nil {
		return m.Phase
	}
	return ""
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimStatus) GetAccessModes() []string {
	if m != nil {
		return m.AccessModes
	}
	return nil
}

func (m *PersistentVolumeClaim_PersistentVolumeClaimStatus) GetCapacity() map[string]string {
	if m != nil {
		return m.Capacity
	}
	return nil
}

type ObjectReference struct {
	Kind            string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	Namespace       string `protobuf:"bytes,2,opt,name=namespace" json:"namespace,omitempty"`
	Name            string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Uid             string `protobuf:"bytes,4,opt,name=uid" json:"uid,omitempty"`
	APIVersion      string `protobuf:"bytes,5,opt,name=API_version,json=APIVersion" json:"API_version,omitempty"`
	ResourceVersion string `protobuf:"bytes,6,opt,name=resource_version,json=resourceVersion" json:"resource_version,omitempty"`
}

func (m *ObjectReference) Reset()                    { *m = ObjectReference{} }
func (m *ObjectReference) String() string            { return proto.CompactTextString(m) }
func (*ObjectReference) ProtoMessage()               {}
func (*ObjectReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *ObjectReference) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *ObjectReference) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *ObjectReference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ObjectReference) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

func (m *ObjectReference) GetAPIVersion() string {
	if m != nil {
		return m.APIVersion
	}
	return ""
}

func (m *ObjectReference) GetResourceVersion() string {
	if m != nil {
		return m.ResourceVersion
	}
	return ""
}

type Service struct {
	Meta   *Meta           `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string          `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec   *Service_Spec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status *Service_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *Service) Reset()                    { *m = Service{} }
func (m *Service) String() string            { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()               {}
func (*Service) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *Service) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Service) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *Service) GetSpec() *Service_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Service) GetStatus() *Service_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Service_Spec struct {
	Type           string               `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
	Ports          []*Service_Spec_Port `protobuf:"bytes,2,rep,name=ports" json:"ports,omitempty"`
	Selectors      map[string]string    `protobuf:"bytes,3,rep,name=selectors" json:"selectors,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ClusterIP      string               `protobuf:"bytes,4,opt,name=clusterIP" json:"clusterIP,omitempty"`
	ExternalIPs    []string             `protobuf:"bytes,5,rep,name=externalIPs" json:"externalIPs,omitempty"`
	LoadbalancerIP string               `protobuf:"bytes,6,opt,name=loadbalancerIP" json:"loadbalancerIP,omitempty"`
}

func (m *Service_Spec) Reset()                    { *m = Service_Spec{} }
func (m *Service_Spec) String() string            { return proto.CompactTextString(m) }
func (*Service_Spec) ProtoMessage()               {}
func (*Service_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 0} }

func (m *Service_Spec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Service_Spec) GetPorts() []*Service_Spec_Port {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *Service_Spec) GetSelectors() map[string]string {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *Service_Spec) GetClusterIP() string {
	if m != nil {
		return m.ClusterIP
	}
	return ""
}

func (m *Service_Spec) GetExternalIPs() []string {
	if m != nil {
		return m.ExternalIPs
	}
	return nil
}

func (m *Service_Spec) GetLoadbalancerIP() string {
	if m != nil {
		return m.LoadbalancerIP
	}
	return ""
}

type Service_Spec_Port struct {
	Name       string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Protocol   string `protobuf:"bytes,2,opt,name=protocol" json:"protocol,omitempty"`
	Port       int32  `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	TargetPort string `protobuf:"bytes,4,opt,name=target_port,json=targetPort" json:"target_port,omitempty"`
	NodePort   int32  `protobuf:"varint,5,opt,name=node_port,json=nodePort" json:"node_port,omitempty"`
}

func (m *Service_Spec_Port) Reset()                    { *m = Service_Spec_Port{} }
func (m *Service_Spec_Port) String() string            { return proto.CompactTextString(m) }
func (*Service_Spec_Port) ProtoMessage()               {}
func (*Service_Spec_Port) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 0, 1} }

func (m *Service_Spec_Port) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Service_Spec_Port) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *Service_Spec_Port) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Service_Spec_Port) GetTargetPort() string {
	if m != nil {
		return m.TargetPort
	}
	return ""
}

func (m *Service_Spec_Port) GetNodePort() int32 {
	if m != nil {
		return m.NodePort
	}
	return 0
}

type Service_Status struct {
	LoadbalancerIngresses []*Service_Status_LoadBalancerIngress `protobuf:"bytes,1,rep,name=loadbalancer_ingresses,json=loadbalancerIngresses" json:"loadbalancer_ingresses,omitempty"`
}

func (m *Service_Status) Reset()                    { *m = Service_Status{} }
func (m *Service_Status) String() string            { return proto.CompactTextString(m) }
func (*Service_Status) ProtoMessage()               {}
func (*Service_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27, 1} }

func (m *Service_Status) GetLoadbalancerIngresses() []*Service_Status_LoadBalancerIngress {
	if m != nil {
		return m.LoadbalancerIngresses
	}
	return nil
}

type Service_Status_LoadBalancerIngress struct {
	HostName string `protobuf:"bytes,1,opt,name=host_name,json=hostName" json:"host_name,omitempty"`
	IP       string `protobuf:"bytes,2,opt,name=IP" json:"IP,omitempty"`
}

func (m *Service_Status_LoadBalancerIngress) Reset()         { *m = Service_Status_LoadBalancerIngress{} }
func (m *Service_Status_LoadBalancerIngress) String() string { return proto.CompactTextString(m) }
func (*Service_Status_LoadBalancerIngress) ProtoMessage()    {}
func (*Service_Status_LoadBalancerIngress) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{27, 1, 0}
}

func (m *Service_Status_LoadBalancerIngress) GetHostName() string {
	if m != nil {
		return m.HostName
	}
	return ""
}

func (m *Service_Status_LoadBalancerIngress) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

type Secret struct {
	Meta *Meta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Data map[string]string `protobuf:"bytes,2,rep,name=data" json:"data,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Type string            `protobuf:"bytes,3,opt,name=type" json:"type,omitempty"`
}

func (m *Secret) Reset()                    { *m = Secret{} }
func (m *Secret) String() string            { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()               {}
func (*Secret) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *Secret) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Secret) GetData() map[string]string {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Secret) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type ReplicationController struct {
	Meta   *Meta                         `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string                        `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec   *ReplicationController_Spec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status *ReplicationController_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *ReplicationController) Reset()                    { *m = ReplicationController{} }
func (m *ReplicationController) String() string            { return proto.CompactTextString(m) }
func (*ReplicationController) ProtoMessage()               {}
func (*ReplicationController) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ReplicationController) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ReplicationController) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *ReplicationController) GetSpec() *ReplicationController_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ReplicationController) GetStatus() *ReplicationController_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type ReplicationController_Spec struct {
	DesiredReplicas int32             `protobuf:"varint,1,opt,name=desired_replicas,json=desiredReplicas" json:"desired_replicas,omitempty"`
	Selectors       map[string]string `protobuf:"bytes,2,rep,name=selectors" json:"selectors,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	PodTemplate     *PodSpec          `protobuf:"bytes,3,opt,name=pod_template,json=podTemplate" json:"pod_template,omitempty"`
}

func (m *ReplicationController_Spec) Reset()                    { *m = ReplicationController_Spec{} }
func (m *ReplicationController_Spec) String() string            { return proto.CompactTextString(m) }
func (*ReplicationController_Spec) ProtoMessage()               {}
func (*ReplicationController_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29, 0} }

func (m *ReplicationController_Spec) GetDesiredReplicas() int32 {
	if m != nil {
		return m.DesiredReplicas
	}
	return 0
}

func (m *ReplicationController_Spec) GetSelectors() map[string]string {
	if m != nil {
		return m.Selectors
	}
	return nil
}

func (m *ReplicationController_Spec) GetPodTemplate() *PodSpec {
	if m != nil {
		return m.PodTemplate
	}
	return nil
}

type ReplicationController_Status struct {
	CurrentReplicas    int32 `protobuf:"varint,1,opt,name=current_replicas,json=currentReplicas" json:"current_replicas,omitempty"`
	ObservedGeneration int64 `protobuf:"varint,2,opt,name=observed_generation,json=observedGeneration" json:"observed_generation,omitempty"`
}

func (m *ReplicationController_Status) Reset()         { *m = ReplicationController_Status{} }
func (m *ReplicationController_Status) String() string { return proto.CompactTextString(m) }
func (*ReplicationController_Status) ProtoMessage()    {}
func (*ReplicationController_Status) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{29, 1}
}

func (m *ReplicationController_Status) GetCurrentReplicas() int32 {
	if m != nil {
		return m.CurrentReplicas
	}
	return 0
}

func (m *ReplicationController_Status) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

type ReplicaSet struct {
	Meta   *Meta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string             `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec   *ReplicaSet_Spec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status *ReplicaSet_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *ReplicaSet) Reset()                    { *m = ReplicaSet{} }
func (m *ReplicaSet) String() string            { return proto.CompactTextString(m) }
func (*ReplicaSet) ProtoMessage()               {}
func (*ReplicaSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *ReplicaSet) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ReplicaSet) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *ReplicaSet) GetSpec() *ReplicaSet_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *ReplicaSet) GetStatus() *ReplicaSet_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type ReplicaSet_Spec struct {
	DesiredReplicas int32          `protobuf:"varint,1,opt,name=desired_replicas,json=desiredReplicas" json:"desired_replicas,omitempty"`
	Selector        *LabelSelector `protobuf:"bytes,2,opt,name=selector" json:"selector,omitempty"`
	PodTemplate     *PodSpec       `protobuf:"bytes,3,opt,name=pod_template,json=podTemplate" json:"pod_template,omitempty"`
}

func (m *ReplicaSet_Spec) Reset()                    { *m = ReplicaSet_Spec{} }
func (m *ReplicaSet_Spec) String() string            { return proto.CompactTextString(m) }
func (*ReplicaSet_Spec) ProtoMessage()               {}
func (*ReplicaSet_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30, 0} }

func (m *ReplicaSet_Spec) GetDesiredReplicas() int32 {
	if m != nil {
		return m.DesiredReplicas
	}
	return 0
}

func (m *ReplicaSet_Spec) GetSelector() *LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *ReplicaSet_Spec) GetPodTemplate() *PodSpec {
	if m != nil {
		return m.PodTemplate
	}
	return nil
}

type ReplicaSet_Status struct {
	CurrentReplicas    int32 `protobuf:"varint,1,opt,name=current_replicas,json=currentReplicas" json:"current_replicas,omitempty"`
	ObservedGeneration int64 `protobuf:"varint,2,opt,name=observed_generation,json=observedGeneration" json:"observed_generation,omitempty"`
}

func (m *ReplicaSet_Status) Reset()                    { *m = ReplicaSet_Status{} }
func (m *ReplicaSet_Status) String() string            { return proto.CompactTextString(m) }
func (*ReplicaSet_Status) ProtoMessage()               {}
func (*ReplicaSet_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30, 1} }

func (m *ReplicaSet_Status) GetCurrentReplicas() int32 {
	if m != nil {
		return m.CurrentReplicas
	}
	return 0
}

func (m *ReplicaSet_Status) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

type DaemonSet struct {
	Meta   *Meta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string            `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec   *DaemonSet_Spec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status *DaemonSet_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *DaemonSet) Reset()                    { *m = DaemonSet{} }
func (m *DaemonSet) String() string            { return proto.CompactTextString(m) }
func (*DaemonSet) ProtoMessage()               {}
func (*DaemonSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *DaemonSet) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *DaemonSet) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *DaemonSet) GetSpec() *DaemonSet_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *DaemonSet) GetStatus() *DaemonSet_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type DaemonSet_Spec struct {
	Selector    *LabelSelector `protobuf:"bytes,1,opt,name=selector" json:"selector,omitempty"`
	PodTemplate *PodSpec       `protobuf:"bytes,2,opt,name=pod_template,json=podTemplate" json:"pod_template,omitempty"`
}

func (m *DaemonSet_Spec) Reset()                    { *m = DaemonSet_Spec{} }
func (m *DaemonSet_Spec) String() string            { return proto.CompactTextString(m) }
func (*DaemonSet_Spec) ProtoMessage()               {}
func (*DaemonSet_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31, 0} }

func (m *DaemonSet_Spec) GetSelector() *LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *DaemonSet_Spec) GetPodTemplate() *PodSpec {
	if m != nil {
		return m.PodTemplate
	}
	return nil
}

type DaemonSet_Status struct {
	CurrentNumberScheduled int32 `protobuf:"varint,1,opt,name=current_number_scheduled,json=currentNumberScheduled" json:"current_number_scheduled,omitempty"`
	NumberMisscheduled     int32 `protobuf:"varint,2,opt,name=number_misscheduled,json=numberMisscheduled" json:"number_misscheduled,omitempty"`
	DesiredNumberScheduled int32 `protobuf:"varint,3,opt,name=desired_number_scheduled,json=desiredNumberScheduled" json:"desired_number_scheduled,omitempty"`
}

func (m *DaemonSet_Status) Reset()                    { *m = DaemonSet_Status{} }
func (m *DaemonSet_Status) String() string            { return proto.CompactTextString(m) }
func (*DaemonSet_Status) ProtoMessage()               {}
func (*DaemonSet_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31, 1} }

func (m *DaemonSet_Status) GetCurrentNumberScheduled() int32 {
	if m != nil {
		return m.CurrentNumberScheduled
	}
	return 0
}

func (m *DaemonSet_Status) GetNumberMisscheduled() int32 {
	if m != nil {
		return m.NumberMisscheduled
	}
	return 0
}

func (m *DaemonSet_Status) GetDesiredNumberScheduled() int32 {
	if m != nil {
		return m.DesiredNumberScheduled
	}
	return 0
}

type Deployment struct {
	Meta   *Meta              `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string             `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec   *Deployment_Spec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status *Deployment_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *Deployment) Reset()                    { *m = Deployment{} }
func (m *Deployment) String() string            { return proto.CompactTextString(m) }
func (*Deployment) ProtoMessage()               {}
func (*Deployment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *Deployment) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Deployment) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *Deployment) GetSpec() *Deployment_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Deployment) GetStatus() *Deployment_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Deployment_Spec struct {
	DesiredReplicas int32          `protobuf:"varint,1,opt,name=desired_replicas,json=desiredReplicas" json:"desired_replicas,omitempty"`
	Selector        *LabelSelector `protobuf:"bytes,2,opt,name=selector" json:"selector,omitempty"`
	PodTemplate     *PodSpec       `protobuf:"bytes,3,opt,name=pod_template,json=podTemplate" json:"pod_template,omitempty"`
}

func (m *Deployment_Spec) Reset()                    { *m = Deployment_Spec{} }
func (m *Deployment_Spec) String() string            { return proto.CompactTextString(m) }
func (*Deployment_Spec) ProtoMessage()               {}
func (*Deployment_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32, 0} }

func (m *Deployment_Spec) GetDesiredReplicas() int32 {
	if m != nil {
		return m.DesiredReplicas
	}
	return 0
}

func (m *Deployment_Spec) GetSelector() *LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *Deployment_Spec) GetPodTemplate() *PodSpec {
	if m != nil {
		return m.PodTemplate
	}
	return nil
}

type Deployment_Status struct {
	ObservedGeneration  int64 `protobuf:"varint,1,opt,name=observed_generation,json=observedGeneration" json:"observed_generation,omitempty"`
	Replicas            int32 `protobuf:"varint,2,opt,name=replicas" json:"replicas,omitempty"`
	UpdatedReplicas     int32 `protobuf:"varint,3,opt,name=updated_replicas,json=updatedReplicas" json:"updated_replicas,omitempty"`
	AvailableReplicas   int32 `protobuf:"varint,4,opt,name=available_replicas,json=availableReplicas" json:"available_replicas,omitempty"`
	UnavailableReplicas int32 `protobuf:"varint,5,opt,name=unavailable_replicas,json=unavailableReplicas" json:"unavailable_replicas,omitempty"`
}

func (m *Deployment_Status) Reset()                    { *m = Deployment_Status{} }
func (m *Deployment_Status) String() string            { return proto.CompactTextString(m) }
func (*Deployment_Status) ProtoMessage()               {}
func (*Deployment_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32, 1} }

func (m *Deployment_Status) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

func (m *Deployment_Status) GetReplicas() int32 {
	if m != nil {
		return m.Replicas
	}
	return 0
}

func (m *Deployment_Status) GetUpdatedReplicas() int32 {
	if m != nil {
		return m.UpdatedReplicas
	}
	return 0
}

func (m *Deployment_Status) GetAvailableReplicas() int32 {
	if m != nil {
		return m.AvailableReplicas
	}
	return 0
}

func (m *Deployment_Status) GetUnavailableReplicas() int32 {
	if m != nil {
		return m.UnavailableReplicas
	}
	return 0
}

type StatefulSet struct {
	Meta   *Meta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	App    string              `protobuf:"bytes,2,opt,name=app" json:"app,omitempty"`
	Spec   *StatefulSet_Spec   `protobuf:"bytes,3,opt,name=spec" json:"spec,omitempty"`
	Status *StatefulSet_Status `protobuf:"bytes,4,opt,name=status" json:"status,omitempty"`
}

func (m *StatefulSet) Reset()                    { *m = StatefulSet{} }
func (m *StatefulSet) String() string            { return proto.CompactTextString(m) }
func (*StatefulSet) ProtoMessage()               {}
func (*StatefulSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *StatefulSet) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *StatefulSet) GetApp() string {
	if m != nil {
		return m.App
	}
	return ""
}

func (m *StatefulSet) GetSpec() *StatefulSet_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *StatefulSet) GetStatus() *StatefulSet_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type StatefulSet_Spec struct {
	DesiredReplicas int32          `protobuf:"varint,1,opt,name=desired_replicas,json=desiredReplicas" json:"desired_replicas,omitempty"`
	Selector        *LabelSelector `protobuf:"bytes,2,opt,name=selector" json:"selector,omitempty"`
	PodTemplate     *PodSpec       `protobuf:"bytes,3,opt,name=pod_template,json=podTemplate" json:"pod_template,omitempty"`
	ServiceName     string         `protobuf:"bytes,4,opt,name=service_name,json=serviceName" json:"service_name,omitempty"`
}

func (m *StatefulSet_Spec) Reset()                    { *m = StatefulSet_Spec{} }
func (m *StatefulSet_Spec) String() string            { return proto.CompactTextString(m) }
func (*StatefulSet_Spec) ProtoMessage()               {}
func (*StatefulSet_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 0} }

func (m *StatefulSet_Spec) GetDesiredReplicas() int32 {
	if m != nil {
		return m.DesiredReplicas
	}
	return 0
}

func (m *StatefulSet_Spec) GetSelector() *LabelSelector {
	if m != nil {
		return m.Selector
	}
	return nil
}

func (m *StatefulSet_Spec) GetPodTemplate() *PodSpec {
	if m != nil {
		return m.PodTemplate
	}
	return nil
}

func (m *StatefulSet_Spec) GetServiceName() string {
	if m != nil {
		return m.ServiceName
	}
	return ""
}

type StatefulSet_Status struct {
	CurrentReplicas    int32 `protobuf:"varint,1,opt,name=current_replicas,json=currentReplicas" json:"current_replicas,omitempty"`
	ObservedGeneration int64 `protobuf:"varint,2,opt,name=observed_generation,json=observedGeneration" json:"observed_generation,omitempty"`
}

func (m *StatefulSet_Status) Reset()                    { *m = StatefulSet_Status{} }
func (m *StatefulSet_Status) String() string            { return proto.CompactTextString(m) }
func (*StatefulSet_Status) ProtoMessage()               {}
func (*StatefulSet_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33, 1} }

func (m *StatefulSet_Status) GetCurrentReplicas() int32 {
	if m != nil {
		return m.CurrentReplicas
	}
	return 0
}

func (m *StatefulSet_Status) GetObservedGeneration() int64 {
	if m != nil {
		return m.ObservedGeneration
	}
	return 0
}

type StorageClass struct {
	Meta        *Meta             `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Provisioner string            `protobuf:"bytes,2,opt,name=provisioner" json:"provisioner,omitempty"`
	Parameters  map[string]string `protobuf:"bytes,3,rep,name=parameters" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *StorageClass) Reset()                    { *m = StorageClass{} }
func (m *StorageClass) String() string            { return proto.CompactTextString(m) }
func (*StorageClass) ProtoMessage()               {}
func (*StorageClass) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *StorageClass) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *StorageClass) GetProvisioner() string {
	if m != nil {
		return m.Provisioner
	}
	return ""
}

func (m *StorageClass) GetParameters() map[string]string {
	if m != nil {
		return m.Parameters
	}
	return nil
}

type LabelSelector struct {
	MatchLabels map[string]string `protobuf:"bytes,1,rep,name=match_labels,json=matchLabels" json:"match_labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *LabelSelector) Reset()                    { *m = LabelSelector{} }
func (m *LabelSelector) String() string            { return proto.CompactTextString(m) }
func (*LabelSelector) ProtoMessage()               {}
func (*LabelSelector) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *LabelSelector) GetMatchLabels() map[string]string {
	if m != nil {
		return m.MatchLabels
	}
	return nil
}

type Event struct {
	Meta           *Meta        `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Reason         string       `protobuf:"bytes,2,opt,name=reason" json:"reason,omitempty"`
	Message        string       `protobuf:"bytes,3,opt,name=message" json:"message,omitempty"`
	Source         *EventSource `protobuf:"bytes,4,opt,name=source" json:"source,omitempty"`
	FirstTimestamp int64        `protobuf:"varint,5,opt,name=first_timestamp,json=firstTimestamp" json:"first_timestamp,omitempty"`
	LastTimestamp  int64        `protobuf:"varint,6,opt,name=last_timestamp,json=lastTimestamp" json:"last_timestamp,omitempty"`
	Count          int32        `protobuf:"varint,7,opt,name=count" json:"count,omitempty"`
	Type           string       `protobuf:"bytes,8,opt,name=type" json:"type,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{36} }

func (m *Event) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Event) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *Event) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Event) GetSource() *EventSource {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Event) GetFirstTimestamp() int64 {
	if m != nil {
		return m.FirstTimestamp
	}
	return 0
}

func (m *Event) GetLastTimestamp() int64 {
	if m != nil {
		return m.LastTimestamp
	}
	return 0
}

func (m *Event) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Event) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type EventSource struct {
	Componenet string `protobuf:"bytes,1,opt,name=componenet" json:"componenet,omitempty"`
	Host       string `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
}

func (m *EventSource) Reset()                    { *m = EventSource{} }
func (m *EventSource) String() string            { return proto.CompactTextString(m) }
func (*EventSource) ProtoMessage()               {}
func (*EventSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{37} }

func (m *EventSource) GetComponenet() string {
	if m != nil {
		return m.Componenet
	}
	return ""
}

func (m *EventSource) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

type Metrics struct {
	CpuUsage    []*Metrics_DataPoint `protobuf:"bytes,1,rep,name=cpu_usage,json=cpuUsage" json:"cpu_usage,omitempty"`
	MemoryUsage []*Metrics_DataPoint `protobuf:"bytes,2,rep,name=memory_usage,json=memoryUsage" json:"memory_usage,omitempty"`
}

func (m *Metrics) Reset()                    { *m = Metrics{} }
func (m *Metrics) String() string            { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()               {}
func (*Metrics) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38} }

func (m *Metrics) GetCpuUsage() []*Metrics_DataPoint {
	if m != nil {
		return m.CpuUsage
	}
	return nil
}

func (m *Metrics) GetMemoryUsage() []*Metrics_DataPoint {
	if m != nil {
		return m.MemoryUsage
	}
	return nil
}

type Metrics_DataPoint struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Value     int64 `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *Metrics_DataPoint) Reset()                    { *m = Metrics_DataPoint{} }
func (m *Metrics_DataPoint) String() string            { return proto.CompactTextString(m) }
func (*Metrics_DataPoint) ProtoMessage()               {}
func (*Metrics_DataPoint) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{38, 0} }

func (m *Metrics_DataPoint) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Metrics_DataPoint) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

type PersistentVolumeRegisterRequest struct {
	Cluster    string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Identifier string `protobuf:"bytes,3,opt,name=identifier" json:"identifier,omitempty"`
	Plugin     string `protobuf:"bytes,4,opt,name=plugin" json:"plugin,omitempty"`
	SizeGb     int64  `protobuf:"varint,5,opt,name=size_gb,json=sizeGb" json:"size_gb,omitempty"`
	Endpoint   string `protobuf:"bytes,6,opt,name=endpoint" json:"endpoint,omitempty"`
}

func (m *PersistentVolumeRegisterRequest) Reset()         { *m = PersistentVolumeRegisterRequest{} }
func (m *PersistentVolumeRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeRegisterRequest) ProtoMessage()    {}
func (*PersistentVolumeRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{39}
}

func (m *PersistentVolumeRegisterRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *PersistentVolumeRegisterRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PersistentVolumeRegisterRequest) GetIdentifier() string {
	if m != nil {
		return m.Identifier
	}
	return ""
}

func (m *PersistentVolumeRegisterRequest) GetPlugin() string {
	if m != nil {
		return m.Plugin
	}
	return ""
}

func (m *PersistentVolumeRegisterRequest) GetSizeGb() int64 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

func (m *PersistentVolumeRegisterRequest) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

type PersistentVolumeUnRegisterRequest struct {
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Name    string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
}

func (m *PersistentVolumeUnRegisterRequest) Reset()         { *m = PersistentVolumeUnRegisterRequest{} }
func (m *PersistentVolumeUnRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeUnRegisterRequest) ProtoMessage()    {}
func (*PersistentVolumeUnRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{40}
}

func (m *PersistentVolumeUnRegisterRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *PersistentVolumeUnRegisterRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PersistentVolumeClaimRegisterRequest struct {
	Cluster   string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	SizeGb    int64  `protobuf:"varint,3,opt,name=size_gb,json=sizeGb" json:"size_gb,omitempty"`
	Namespace string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *PersistentVolumeClaimRegisterRequest) Reset()         { *m = PersistentVolumeClaimRegisterRequest{} }
func (m *PersistentVolumeClaimRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeClaimRegisterRequest) ProtoMessage()    {}
func (*PersistentVolumeClaimRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{41}
}

func (m *PersistentVolumeClaimRegisterRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *PersistentVolumeClaimRegisterRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PersistentVolumeClaimRegisterRequest) GetSizeGb() int64 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

func (m *PersistentVolumeClaimRegisterRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type PersistentVolumeClaimUnRegisterRequest struct {
	Cluster   string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Namespace string `protobuf:"bytes,3,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *PersistentVolumeClaimUnRegisterRequest) Reset() {
	*m = PersistentVolumeClaimUnRegisterRequest{}
}
func (m *PersistentVolumeClaimUnRegisterRequest) String() string { return proto.CompactTextString(m) }
func (*PersistentVolumeClaimUnRegisterRequest) ProtoMessage()    {}
func (*PersistentVolumeClaimUnRegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{42}
}

func (m *PersistentVolumeClaimUnRegisterRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *PersistentVolumeClaimUnRegisterRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PersistentVolumeClaimUnRegisterRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type Alert struct {
	Meta   *Meta            `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *Alert_AlertSpec `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status string           `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *Alert) Reset()                    { *m = Alert{} }
func (m *Alert) String() string            { return proto.CompactTextString(m) }
func (*Alert) ProtoMessage()               {}
func (*Alert) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43} }

func (m *Alert) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Alert) GetSpec() *Alert_AlertSpec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Alert) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type Alert_AlertSpec struct {
	IcingaParam    *Alert_AlertSpec_IcingaParam     `protobuf:"bytes,1,opt,name=icinga_param,json=icingaParam" json:"icinga_param,omitempty"`
	CheckCommand   string                           `protobuf:"bytes,2,opt,name=check_command,json=checkCommand" json:"check_command,omitempty"`
	NotifierParams []*Alert_AlertSpec_NotifierParam `protobuf:"bytes,3,rep,name=notifier_params,json=notifierParams" json:"notifier_params,omitempty"`
	Vars           map[string]string                `protobuf:"bytes,4,rep,name=vars" json:"vars,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Alert_AlertSpec) Reset()                    { *m = Alert_AlertSpec{} }
func (m *Alert_AlertSpec) String() string            { return proto.CompactTextString(m) }
func (*Alert_AlertSpec) ProtoMessage()               {}
func (*Alert_AlertSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{43, 0} }

func (m *Alert_AlertSpec) GetIcingaParam() *Alert_AlertSpec_IcingaParam {
	if m != nil {
		return m.IcingaParam
	}
	return nil
}

func (m *Alert_AlertSpec) GetCheckCommand() string {
	if m != nil {
		return m.CheckCommand
	}
	return ""
}

func (m *Alert_AlertSpec) GetNotifierParams() []*Alert_AlertSpec_NotifierParam {
	if m != nil {
		return m.NotifierParams
	}
	return nil
}

func (m *Alert_AlertSpec) GetVars() map[string]string {
	if m != nil {
		return m.Vars
	}
	return nil
}

type Alert_AlertSpec_IcingaParam struct {
	CheckIntervalSec int64 `protobuf:"varint,1,opt,name=check_interval_sec,json=checkIntervalSec" json:"check_interval_sec,omitempty"`
	AlertIntervalSec int64 `protobuf:"varint,2,opt,name=alert_interval_sec,json=alertIntervalSec" json:"alert_interval_sec,omitempty"`
}

func (m *Alert_AlertSpec_IcingaParam) Reset()         { *m = Alert_AlertSpec_IcingaParam{} }
func (m *Alert_AlertSpec_IcingaParam) String() string { return proto.CompactTextString(m) }
func (*Alert_AlertSpec_IcingaParam) ProtoMessage()    {}
func (*Alert_AlertSpec_IcingaParam) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{43, 0, 1}
}

func (m *Alert_AlertSpec_IcingaParam) GetCheckIntervalSec() int64 {
	if m != nil {
		return m.CheckIntervalSec
	}
	return 0
}

func (m *Alert_AlertSpec_IcingaParam) GetAlertIntervalSec() int64 {
	if m != nil {
		return m.AlertIntervalSec
	}
	return 0
}

type Alert_AlertSpec_NotifierParam struct {
	State   string `protobuf:"bytes,1,opt,name=state" json:"state,omitempty"`
	UserUid string `protobuf:"bytes,2,opt,name=user_uid,json=userUid" json:"user_uid,omitempty"`
	Method  string `protobuf:"bytes,3,opt,name=method" json:"method,omitempty"`
}

func (m *Alert_AlertSpec_NotifierParam) Reset()         { *m = Alert_AlertSpec_NotifierParam{} }
func (m *Alert_AlertSpec_NotifierParam) String() string { return proto.CompactTextString(m) }
func (*Alert_AlertSpec_NotifierParam) ProtoMessage()    {}
func (*Alert_AlertSpec_NotifierParam) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{43, 0, 2}
}

func (m *Alert_AlertSpec_NotifierParam) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Alert_AlertSpec_NotifierParam) GetUserUid() string {
	if m != nil {
		return m.UserUid
	}
	return ""
}

func (m *Alert_AlertSpec_NotifierParam) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

type Role struct {
	Meta  *Meta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Rules []*Rule `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *Role) Reset()                    { *m = Role{} }
func (m *Role) String() string            { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()               {}
func (*Role) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{44} }

func (m *Role) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Role) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type RoleBinding struct {
	Meta     *Meta            `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Subjects []*Subject       `protobuf:"bytes,2,rep,name=subjects" json:"subjects,omitempty"`
	RoleRef  *ObjectReference `protobuf:"bytes,3,opt,name=role_ref,json=roleRef" json:"role_ref,omitempty"`
}

func (m *RoleBinding) Reset()                    { *m = RoleBinding{} }
func (m *RoleBinding) String() string            { return proto.CompactTextString(m) }
func (*RoleBinding) ProtoMessage()               {}
func (*RoleBinding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{45} }

func (m *RoleBinding) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RoleBinding) GetSubjects() []*Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *RoleBinding) GetRoleRef() *ObjectReference {
	if m != nil {
		return m.RoleRef
	}
	return nil
}

type ClusterRole struct {
	Meta  *Meta   `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Rules []*Rule `protobuf:"bytes,2,rep,name=rules" json:"rules,omitempty"`
}

func (m *ClusterRole) Reset()                    { *m = ClusterRole{} }
func (m *ClusterRole) String() string            { return proto.CompactTextString(m) }
func (*ClusterRole) ProtoMessage()               {}
func (*ClusterRole) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{46} }

func (m *ClusterRole) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ClusterRole) GetRules() []*Rule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type ClusterRoleBinding struct {
	Meta     *Meta            `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Subjects []*Subject       `protobuf:"bytes,2,rep,name=subjects" json:"subjects,omitempty"`
	RoleRef  *ObjectReference `protobuf:"bytes,3,opt,name=role_ref,json=roleRef" json:"role_ref,omitempty"`
}

func (m *ClusterRoleBinding) Reset()                    { *m = ClusterRoleBinding{} }
func (m *ClusterRoleBinding) String() string            { return proto.CompactTextString(m) }
func (*ClusterRoleBinding) ProtoMessage()               {}
func (*ClusterRoleBinding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{47} }

func (m *ClusterRoleBinding) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *ClusterRoleBinding) GetSubjects() []*Subject {
	if m != nil {
		return m.Subjects
	}
	return nil
}

func (m *ClusterRoleBinding) GetRoleRef() *ObjectReference {
	if m != nil {
		return m.RoleRef
	}
	return nil
}

type Rule struct {
	Verbs           []string `protobuf:"bytes,1,rep,name=verbs" json:"verbs,omitempty"`
	ApiGroups       []string `protobuf:"bytes,2,rep,name=api_groups,json=apiGroups" json:"api_groups,omitempty"`
	Resources       []string `protobuf:"bytes,3,rep,name=resources" json:"resources,omitempty"`
	ResourceNames   []string `protobuf:"bytes,4,rep,name=resource_names,json=resourceNames" json:"resource_names,omitempty"`
	NonResourceUrls []string `protobuf:"bytes,5,rep,name=non_resource_urls,json=nonResourceUrls" json:"non_resource_urls,omitempty"`
}

func (m *Rule) Reset()                    { *m = Rule{} }
func (m *Rule) String() string            { return proto.CompactTextString(m) }
func (*Rule) ProtoMessage()               {}
func (*Rule) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{48} }

func (m *Rule) GetVerbs() []string {
	if m != nil {
		return m.Verbs
	}
	return nil
}

func (m *Rule) GetApiGroups() []string {
	if m != nil {
		return m.ApiGroups
	}
	return nil
}

func (m *Rule) GetResources() []string {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *Rule) GetResourceNames() []string {
	if m != nil {
		return m.ResourceNames
	}
	return nil
}

func (m *Rule) GetNonResourceUrls() []string {
	if m != nil {
		return m.NonResourceUrls
	}
	return nil
}

type Subject struct {
	Kind       string `protobuf:"bytes,1,opt,name=kind" json:"kind,omitempty"`
	ApiVersion string `protobuf:"bytes,2,opt,name=api_version,json=apiVersion" json:"api_version,omitempty"`
	Name       string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	Namespace  string `protobuf:"bytes,4,opt,name=namespace" json:"namespace,omitempty"`
}

func (m *Subject) Reset()                    { *m = Subject{} }
func (m *Subject) String() string            { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()               {}
func (*Subject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{49} }

func (m *Subject) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Subject) GetApiVersion() string {
	if m != nil {
		return m.ApiVersion
	}
	return ""
}

func (m *Subject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Subject) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

type CronJob struct {
	Meta   *Meta           `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Space  *CronJob_Spec   `protobuf:"bytes,2,opt,name=space" json:"space,omitempty"`
	Status *CronJob_Status `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *CronJob) Reset()                    { *m = CronJob{} }
func (m *CronJob) String() string            { return proto.CompactTextString(m) }
func (*CronJob) ProtoMessage()               {}
func (*CronJob) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50} }

func (m *CronJob) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *CronJob) GetSpace() *CronJob_Spec {
	if m != nil {
		return m.Space
	}
	return nil
}

func (m *CronJob) GetStatus() *CronJob_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type CronJob_Spec struct {
	Schedule                string   `protobuf:"bytes,1,opt,name=schedule" json:"schedule,omitempty"`
	StartingDeadlineSeconds int64    `protobuf:"varint,2,opt,name=starting_deadline_seconds,json=startingDeadlineSeconds" json:"starting_deadline_seconds,omitempty"`
	ConcurrencyPolicy       string   `protobuf:"bytes,3,opt,name=concurrency_policy,json=concurrencyPolicy" json:"concurrency_policy,omitempty"`
	Suspend                 bool     `protobuf:"varint,4,opt,name=suspend" json:"suspend,omitempty"`
	Template                *JobSpec `protobuf:"bytes,5,opt,name=template" json:"template,omitempty"`
}

func (m *CronJob_Spec) Reset()                    { *m = CronJob_Spec{} }
func (m *CronJob_Spec) String() string            { return proto.CompactTextString(m) }
func (*CronJob_Spec) ProtoMessage()               {}
func (*CronJob_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50, 0} }

func (m *CronJob_Spec) GetSchedule() string {
	if m != nil {
		return m.Schedule
	}
	return ""
}

func (m *CronJob_Spec) GetStartingDeadlineSeconds() int64 {
	if m != nil {
		return m.StartingDeadlineSeconds
	}
	return 0
}

func (m *CronJob_Spec) GetConcurrencyPolicy() string {
	if m != nil {
		return m.ConcurrencyPolicy
	}
	return ""
}

func (m *CronJob_Spec) GetSuspend() bool {
	if m != nil {
		return m.Suspend
	}
	return false
}

func (m *CronJob_Spec) GetTemplate() *JobSpec {
	if m != nil {
		return m.Template
	}
	return nil
}

type CronJob_Status struct {
	Active           []*ObjectReference `protobuf:"bytes,1,rep,name=active" json:"active,omitempty"`
	LastScheduleTime int64              `protobuf:"varint,2,opt,name=last_schedule_time,json=lastScheduleTime" json:"last_schedule_time,omitempty"`
}

func (m *CronJob_Status) Reset()                    { *m = CronJob_Status{} }
func (m *CronJob_Status) String() string            { return proto.CompactTextString(m) }
func (*CronJob_Status) ProtoMessage()               {}
func (*CronJob_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{50, 1} }

func (m *CronJob_Status) GetActive() []*ObjectReference {
	if m != nil {
		return m.Active
	}
	return nil
}

func (m *CronJob_Status) GetLastScheduleTime() int64 {
	if m != nil {
		return m.LastScheduleTime
	}
	return 0
}

type Certificate struct {
	Meta   *Meta               `protobuf:"bytes,1,opt,name=meta" json:"meta,omitempty"`
	Spec   *Certificate_Spec   `protobuf:"bytes,2,opt,name=spec" json:"spec,omitempty"`
	Status *Certificate_Status `protobuf:"bytes,3,opt,name=status" json:"status,omitempty"`
}

func (m *Certificate) Reset()                    { *m = Certificate{} }
func (m *Certificate) String() string            { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()               {}
func (*Certificate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51} }

func (m *Certificate) GetMeta() *Meta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Certificate) GetSpec() *Certificate_Spec {
	if m != nil {
		return m.Spec
	}
	return nil
}

func (m *Certificate) GetStatus() *Certificate_Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Certificate_Spec struct {
	// Obtain a single certificate for all the domains. The first Domain provided wiil
	// be counted as Name and other domains will be in SANs.
	Domains []string `protobuf:"bytes,1,rep,name=domains" json:"domains,omitempty"`
	// Provider to resolve challange. Valid Providers are
	// "http":
	// "cloudflare":
	// "digitalocean":
	// "dnsimple":
	// "dyn":
	// "gandi":
	// "googlecloud":
	// "linode":
	// "namecheap":
	// "ovh":
	// "pdns":
	// "rfc2136":
	// "route53":
	// "vultr":
	Provider                     string           `protobuf:"bytes,2,opt,name=provider" json:"provider,omitempty"`
	Email                        string           `protobuf:"bytes,3,opt,name=email" json:"email,omitempty"`
	HTTPProviderIngressReference *ObjectReference `protobuf:"bytes,4,opt,name=HTTP_provider_ingress_reference,json=HTTPProviderIngressReference" json:"HTTP_provider_ingress_reference,omitempty"`
	// ProviderCredentialSecret Must Contain Secrets for that specific Providers.
	// All the Key names for DNS providers needs to maintain the following formate:
	//
	// http
	// HTTP Provider needs an Ingress or ExtendedIngress reference in HTTP_provider_ingress_reference.
	//
	// cloudflare
	// CLOUDFLARE_EMAIL: The email of the cloudflare user
	// CLOUDFLARE_API_KEY: The API key corresponding to the email
	//
	// digitalocean
	// DO_AUTH_TOKEN: The digital ocean authorization token
	//
	// dnsimple
	// DNSIMPLE_EMAIL: The email fo the DNSimple user
	// DNSIMPLE_API_KEY: The API key corresponding to the email
	//
	// dnsmadeeasy
	// DNSMADEEASY_API_KEY: The API key for DNS Made Easy
	// DNSMADEEASY_API_SECRET: The api secret corresponding with the API key
	// DNSMADEEASY_SANDBOX: A boolean flag, if set to true or 1, requests will be sent to the sandbox API
	//
	// dyn
	// DYN_CUSTOMER_NAME: The customer name of the Dyn user
	// DYN_USER_NAME: The user name of the Dyn user
	// DYN_PASSWORD: The password of the Dyn user
	//
	// gandi
	// GANDI_API_KEY: The API key for Gandi
	//
	// googlecloud
	// GCE_PROJECT: The name of the Google Cloud project to use
	//
	// linode
	// LINODE_API_KEY: API key for linode
	//
	// namecheap
	// NAMECHEAP_API_USER: The username of the namecheap user
	// NAMECHEAP_API_KEY: The API key corresponding with the namecheap user
	//
	// ovh
	// OVH_ENDPOINT: The URL of the API endpoint to use
	// OVH_APPLICATION_KEY: The application key
	// OVH_APPLICATION_SECRET: The secret corresponding to the application key
	// OVH_CONSUMER_KEY: The consumer key
	//
	// pdns
	// PDNS_API_KEY: The API key to use
	//
	// rfc2136
	// RFC2136_NAMESERVER: The network address of the provider, in the form of "host" or "host:port"
	// RFC2136_TSIG_ALGORITHM: The algorithm to use for TSIG authentication.
	// RFC2136_TSIG_KEY: The key to use for TSIG authentication.
	// RFC2136_TSIG_SECRET: The secret to use for TSIG authentication.
	//
	// route53
	// AWS_ACCESS_KEY_ID: The access key ID
	// AWS_SECRET_ACCESS_KEY: The secret corresponding to the access key
	//
	// vultr
	// VULTR_API_KEY: The API key to use
	ProviderCredentialSecretName string `protobuf:"bytes,5,opt,name=provider_credential_secret_name,json=providerCredentialSecretName" json:"provider_credential_secret_name,omitempty"`
	ACMEUserSecretName           string `protobuf:"bytes,6,opt,name=ACME_user_secret_name,json=ACMEUserSecretName" json:"ACME_user_secret_name,omitempty"`
	// Provides Custom acme server url to issue certificates. If empty it
	// uses let's encrypt servers.
	ACMEServerURL string `protobuf:"bytes,7,opt,name=ACME_serverURL,json=ACMEServerURL" json:"ACME_serverURL,omitempty"`
}

func (m *Certificate_Spec) Reset()                    { *m = Certificate_Spec{} }
func (m *Certificate_Spec) String() string            { return proto.CompactTextString(m) }
func (*Certificate_Spec) ProtoMessage()               {}
func (*Certificate_Spec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51, 0} }

func (m *Certificate_Spec) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *Certificate_Spec) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Certificate_Spec) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Certificate_Spec) GetHTTPProviderIngressReference() *ObjectReference {
	if m != nil {
		return m.HTTPProviderIngressReference
	}
	return nil
}

func (m *Certificate_Spec) GetProviderCredentialSecretName() string {
	if m != nil {
		return m.ProviderCredentialSecretName
	}
	return ""
}

func (m *Certificate_Spec) GetACMEUserSecretName() string {
	if m != nil {
		return m.ACMEUserSecretName
	}
	return ""
}

func (m *Certificate_Spec) GetACMEServerURL() string {
	if m != nil {
		return m.ACMEServerURL
	}
	return ""
}

type Certificate_Status struct {
	CertificateObtained bool                                       `protobuf:"varint,1,opt,name=certificate_obtained,json=certificateObtained" json:"certificate_obtained,omitempty"`
	Message             string                                     `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	CreatedAt           int64                                      `protobuf:"varint,3,opt,name=created_at,json=createdAt" json:"created_at,omitempty"`
	ACMEUserSecretName  string                                     `protobuf:"bytes,4,opt,name=ACME_user_secret_name,json=ACMEUserSecretName" json:"ACME_user_secret_name,omitempty"`
	Details             *Certificate_Status_ACMECertificateDetails `protobuf:"bytes,5,opt,name=details" json:"details,omitempty"`
}

func (m *Certificate_Status) Reset()                    { *m = Certificate_Status{} }
func (m *Certificate_Status) String() string            { return proto.CompactTextString(m) }
func (*Certificate_Status) ProtoMessage()               {}
func (*Certificate_Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{51, 1} }

func (m *Certificate_Status) GetCertificateObtained() bool {
	if m != nil {
		return m.CertificateObtained
	}
	return false
}

func (m *Certificate_Status) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Certificate_Status) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Certificate_Status) GetACMEUserSecretName() string {
	if m != nil {
		return m.ACMEUserSecretName
	}
	return ""
}

func (m *Certificate_Status) GetDetails() *Certificate_Status_ACMECertificateDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type Certificate_Status_ACMECertificateDetails struct {
	Domain        string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	CertURL       string `protobuf:"bytes,2,opt,name=certURL" json:"certURL,omitempty"`
	CertStableURL string `protobuf:"bytes,3,opt,name=cert_stableURL,json=certStableURL" json:"cert_stableURL,omitempty"`
	AccountRef    string `protobuf:"bytes,4,opt,name=account_ref,json=accountRef" json:"account_ref,omitempty"`
}

func (m *Certificate_Status_ACMECertificateDetails) Reset() {
	*m = Certificate_Status_ACMECertificateDetails{}
}
func (m *Certificate_Status_ACMECertificateDetails) String() string { return proto.CompactTextString(m) }
func (*Certificate_Status_ACMECertificateDetails) ProtoMessage()    {}
func (*Certificate_Status_ACMECertificateDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{51, 1, 0}
}

func (m *Certificate_Status_ACMECertificateDetails) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Certificate_Status_ACMECertificateDetails) GetCertURL() string {
	if m != nil {
		return m.CertURL
	}
	return ""
}

func (m *Certificate_Status_ACMECertificateDetails) GetCertStableURL() string {
	if m != nil {
		return m.CertStableURL
	}
	return ""
}

func (m *Certificate_Status_ACMECertificateDetails) GetAccountRef() string {
	if m != nil {
		return m.AccountRef
	}
	return ""
}

// PersistentVolumeSource is similar to VolumeSource but meant for the
// administrator who creates PVs. Exactly one of its members must be set.
type PersistentVolumeSource struct {
	// GCEPersistentDisk represents a GCE Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
	GcePersistentDisk *GCEPersistentDiskVolumeSource `protobuf:"bytes,1,opt,name=gcePersistentDisk" json:"gcePersistentDisk,omitempty"`
	// AWSElasticBlockStore represents an AWS Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
	AwsElasticBlockStore *AWSElasticBlockStoreVolumeSource `protobuf:"bytes,2,opt,name=awsElasticBlockStore" json:"awsElasticBlockStore,omitempty"`
	// HostPath represents a directory on the host.
	// Provisioned by a developer or tester.
	// This is useful for single-node development and testing only!
	// On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
	HostPath *HostPathVolumeSource `protobuf:"bytes,3,opt,name=hostPath" json:"hostPath,omitempty"`
	// Glusterfs represents a Glusterfs volume that is attached to a host and
	// exposed to the pod. Provisioned by an admin.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md
	Glusterfs *GlusterfsVolumeSource `protobuf:"bytes,4,opt,name=glusterfs" json:"glusterfs,omitempty"`
	// NFS represents an NFS mount on the host. Provisioned by an admin.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
	Nfs *NFSVolumeSource `protobuf:"bytes,5,opt,name=nfs" json:"nfs,omitempty"`
	// RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md
	Rbd *RBDVolumeSource `protobuf:"bytes,6,opt,name=rbd" json:"rbd,omitempty"`
	// ISCSI represents an ISCSI Disk resource that is attached to a
	// kubelet's host machine and then exposed to the pod. Provisioned by an admin.
	Iscsi *ISCSIVolumeSource `protobuf:"bytes,7,opt,name=iscsi" json:"iscsi,omitempty"`
	// Cinder represents a cinder volume attached and mounted on kubelets host machine
	// More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
	Cinder *CinderVolumeSource `protobuf:"bytes,8,opt,name=cinder" json:"cinder,omitempty"`
	// CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
	Cephfs *CephFSVolumeSource `protobuf:"bytes,9,opt,name=cephfs" json:"cephfs,omitempty"`
	// FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
	Fc *FCVolumeSource `protobuf:"bytes,10,opt,name=fc" json:"fc,omitempty"`
	// Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
	Flocker *FlockerVolumeSource `protobuf:"bytes,11,opt,name=flocker" json:"flocker,omitempty"`
	// FlexVolume represents a generic volume resource that is
	// provisioned/attached using an exec based plugin. This is an
	// alpha feature and may change in future.
	FlexVolume *FlexVolumeSource `protobuf:"bytes,12,opt,name=flexVolume" json:"flexVolume,omitempty"`
	// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
	AzureFile *AzureFileVolumeSource `protobuf:"bytes,13,opt,name=azureFile" json:"azureFile,omitempty"`
	// VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
	VsphereVolume *VsphereVirtualDiskVolumeSource `protobuf:"bytes,14,opt,name=vsphereVolume" json:"vsphereVolume,omitempty"`
	// Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
	Quobyte *QuobyteVolumeSource `protobuf:"bytes,15,opt,name=quobyte" json:"quobyte,omitempty"`
	// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
	AzureDisk *AzureDiskVolumeSource `protobuf:"bytes,16,opt,name=azureDisk" json:"azureDisk,omitempty"`
}

func (m *PersistentVolumeSource) Reset()                    { *m = PersistentVolumeSource{} }
func (m *PersistentVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*PersistentVolumeSource) ProtoMessage()               {}
func (*PersistentVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{52} }

func (m *PersistentVolumeSource) GetGcePersistentDisk() *GCEPersistentDiskVolumeSource {
	if m != nil {
		return m.GcePersistentDisk
	}
	return nil
}

func (m *PersistentVolumeSource) GetAwsElasticBlockStore() *AWSElasticBlockStoreVolumeSource {
	if m != nil {
		return m.AwsElasticBlockStore
	}
	return nil
}

func (m *PersistentVolumeSource) GetHostPath() *HostPathVolumeSource {
	if m != nil {
		return m.HostPath
	}
	return nil
}

func (m *PersistentVolumeSource) GetGlusterfs() *GlusterfsVolumeSource {
	if m != nil {
		return m.Glusterfs
	}
	return nil
}

func (m *PersistentVolumeSource) GetNfs() *NFSVolumeSource {
	if m != nil {
		return m.Nfs
	}
	return nil
}

func (m *PersistentVolumeSource) GetRbd() *RBDVolumeSource {
	if m != nil {
		return m.Rbd
	}
	return nil
}

func (m *PersistentVolumeSource) GetIscsi() *ISCSIVolumeSource {
	if m != nil {
		return m.Iscsi
	}
	return nil
}

func (m *PersistentVolumeSource) GetCinder() *CinderVolumeSource {
	if m != nil {
		return m.Cinder
	}
	return nil
}

func (m *PersistentVolumeSource) GetCephfs() *CephFSVolumeSource {
	if m != nil {
		return m.Cephfs
	}
	return nil
}

func (m *PersistentVolumeSource) GetFc() *FCVolumeSource {
	if m != nil {
		return m.Fc
	}
	return nil
}

func (m *PersistentVolumeSource) GetFlocker() *FlockerVolumeSource {
	if m != nil {
		return m.Flocker
	}
	return nil
}

func (m *PersistentVolumeSource) GetFlexVolume() *FlexVolumeSource {
	if m != nil {
		return m.FlexVolume
	}
	return nil
}

func (m *PersistentVolumeSource) GetAzureFile() *AzureFileVolumeSource {
	if m != nil {
		return m.AzureFile
	}
	return nil
}

func (m *PersistentVolumeSource) GetVsphereVolume() *VsphereVirtualDiskVolumeSource {
	if m != nil {
		return m.VsphereVolume
	}
	return nil
}

func (m *PersistentVolumeSource) GetQuobyte() *QuobyteVolumeSource {
	if m != nil {
		return m.Quobyte
	}
	return nil
}

func (m *PersistentVolumeSource) GetAzureDisk() *AzureDiskVolumeSource {
	if m != nil {
		return m.AzureDisk
	}
	return nil
}

// Represents a Persistent Disk resource in AWS.
//
// An AWS EBS disk must exist before mounting to a container. The disk
// must also be in the same AWS zone as the kubelet. An AWS EBS disk
// can only be mounted as read/write once. AWS EBS volumes support
// ownership management and SELinux relabeling.
type AWSElasticBlockStoreVolumeSource struct {
	// Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
	VolumeID string `protobuf:"bytes,1,opt,name=volumeID" json:"volumeID,omitempty"`
	// Filesystem type of the volume that you want to mount.
	// Tip: Ensure that the filesystem type is supported by the host operating system.
	// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
	// TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType string `protobuf:"bytes,2,opt,name=fsType" json:"fsType,omitempty"`
	// The partition in the volume that you want to mount.
	// If omitted, the default is to mount by volume name.
	// Examples: For volume /dev/sda1, you specify the partition as "1".
	// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
	Partition int32 `protobuf:"varint,3,opt,name=partition" json:"partition,omitempty"`
	// Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
	// If omitted, the default is "false".
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
	ReadOnly bool `protobuf:"varint,4,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *AWSElasticBlockStoreVolumeSource) Reset()         { *m = AWSElasticBlockStoreVolumeSource{} }
func (m *AWSElasticBlockStoreVolumeSource) String() string { return proto.CompactTextString(m) }
func (*AWSElasticBlockStoreVolumeSource) ProtoMessage()    {}
func (*AWSElasticBlockStoreVolumeSource) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{53}
}

func (m *AWSElasticBlockStoreVolumeSource) GetVolumeID() string {
	if m != nil {
		return m.VolumeID
	}
	return ""
}

func (m *AWSElasticBlockStoreVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *AWSElasticBlockStoreVolumeSource) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *AWSElasticBlockStoreVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a host path mapped into a pod.
// Host path volumes do not support ownership management or SELinux relabeling.
type HostPathVolumeSource struct {
	// Path of the directory on the host.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *HostPathVolumeSource) Reset()                    { *m = HostPathVolumeSource{} }
func (m *HostPathVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*HostPathVolumeSource) ProtoMessage()               {}
func (*HostPathVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{54} }

func (m *HostPathVolumeSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Represents an NFS mount that lasts the lifetime of a pod.
// NFS volumes do not support ownership management or SELinux relabeling.
type NFSVolumeSource struct {
	// Server is the hostname or IP address of the NFS server.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
	Server string `protobuf:"bytes,1,opt,name=server" json:"server,omitempty"`
	// Path that is exported by the NFS server.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// ReadOnly here will force
	// the NFS export to be mounted with read-only permissions.
	// Defaults to false.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
	ReadOnly bool `protobuf:"varint,3,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *NFSVolumeSource) Reset()                    { *m = NFSVolumeSource{} }
func (m *NFSVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*NFSVolumeSource) ProtoMessage()               {}
func (*NFSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{55} }

func (m *NFSVolumeSource) GetServer() string {
	if m != nil {
		return m.Server
	}
	return ""
}

func (m *NFSVolumeSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *NFSVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a Fibre Channel volume.
// Fibre Channel volumes can only be mounted as read/write once.
// Fibre Channel volumes support ownership management and SELinux relabeling.
type FCVolumeSource struct {
	// Required: FC target worldwide names (WWNs)
	TargetWWNs []string `protobuf:"bytes,1,rep,name=targetWWNs" json:"targetWWNs,omitempty"`
	// Required: FC target lun number
	Lun int32 `protobuf:"varint,2,opt,name=lun" json:"lun,omitempty"`
	// Filesystem type to mount.
	// Must be a filesystem type supported by the host operating system.
	// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	// TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType string `protobuf:"bytes,3,opt,name=fsType" json:"fsType,omitempty"`
	// Optional: Defaults to false (read/write). ReadOnly here will force
	// the ReadOnly setting in VolumeMounts.
	ReadOnly bool `protobuf:"varint,4,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *FCVolumeSource) Reset()                    { *m = FCVolumeSource{} }
func (m *FCVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*FCVolumeSource) ProtoMessage()               {}
func (*FCVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{56} }

func (m *FCVolumeSource) GetTargetWWNs() []string {
	if m != nil {
		return m.TargetWWNs
	}
	return nil
}

func (m *FCVolumeSource) GetLun() int32 {
	if m != nil {
		return m.Lun
	}
	return 0
}

func (m *FCVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *FCVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
type FlexVolumeSource struct {
	// Driver is the name of the driver to use for this volume.
	Driver string `protobuf:"bytes,1,opt,name=driver" json:"driver,omitempty"`
	// Filesystem type to mount.
	// Must be a filesystem type supported by the host operating system.
	// Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
	FsType string `protobuf:"bytes,2,opt,name=fsType" json:"fsType,omitempty"`
	// Optional: SecretRef is reference to the secret object containing
	// sensitive information to pass to the plugin scripts. This may be
	// empty if no secret object is specified. If the secret object
	// contains more than one secret, all secrets are passed to the plugin
	// scripts.
	SecretRef *ObjectReference `protobuf:"bytes,3,opt,name=secretRef" json:"secretRef,omitempty"`
	// Optional: Defaults to false (read/write). ReadOnly here will force
	// the ReadOnly setting in VolumeMounts.
	ReadOnly bool `protobuf:"varint,4,opt,name=readOnly" json:"readOnly,omitempty"`
	// Optional: Extra command options if any.
	Options map[string]string `protobuf:"bytes,5,rep,name=options" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *FlexVolumeSource) Reset()                    { *m = FlexVolumeSource{} }
func (m *FlexVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*FlexVolumeSource) ProtoMessage()               {}
func (*FlexVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{57} }

func (m *FlexVolumeSource) GetDriver() string {
	if m != nil {
		return m.Driver
	}
	return ""
}

func (m *FlexVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *FlexVolumeSource) GetSecretRef() *ObjectReference {
	if m != nil {
		return m.SecretRef
	}
	return nil
}

func (m *FlexVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *FlexVolumeSource) GetOptions() map[string]string {
	if m != nil {
		return m.Options
	}
	return nil
}

// Represents a Flocker volume mounted by the Flocker agent.
// Flocker volumes do not support ownership management or SELinux relabeling.
type FlockerVolumeSource struct {
	// Required: the volume name. This is going to be store on metadata -> name on the payload for Flocker
	DatasetName string `protobuf:"bytes,1,opt,name=datasetName" json:"datasetName,omitempty"`
}

func (m *FlockerVolumeSource) Reset()                    { *m = FlockerVolumeSource{} }
func (m *FlockerVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*FlockerVolumeSource) ProtoMessage()               {}
func (*FlockerVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{58} }

func (m *FlockerVolumeSource) GetDatasetName() string {
	if m != nil {
		return m.DatasetName
	}
	return ""
}

// Represents a Persistent Disk resource in Google Compute Engine.
//
// A GCE PD must exist before mounting to a container. The disk must
// also be in the same GCE project and zone as the kubelet. A GCE PD
// can only be mounted as read/write once or read-only many times. GCE
// PDs support ownership management and SELinux relabeling.
type GCEPersistentDiskVolumeSource struct {
	// Unique name of the PD resource in GCE. Used to identify the disk in GCE.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
	PdName string `protobuf:"bytes,1,opt,name=pdName" json:"pdName,omitempty"`
	// Filesystem type of the volume that you want to mount.
	// Tip: Ensure that the filesystem type is supported by the host operating system.
	// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
	// TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType string `protobuf:"bytes,2,opt,name=fsType" json:"fsType,omitempty"`
	// The partition in the volume that you want to mount.
	// If omitted, the default is to mount by volume name.
	// Examples: For volume /dev/sda1, you specify the partition as "1".
	// Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
	Partition int32 `protobuf:"varint,3,opt,name=partition" json:"partition,omitempty"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts.
	// Defaults to false.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
	ReadOnly bool `protobuf:"varint,4,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *GCEPersistentDiskVolumeSource) Reset()                    { *m = GCEPersistentDiskVolumeSource{} }
func (m *GCEPersistentDiskVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*GCEPersistentDiskVolumeSource) ProtoMessage()               {}
func (*GCEPersistentDiskVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{59} }

func (m *GCEPersistentDiskVolumeSource) GetPdName() string {
	if m != nil {
		return m.PdName
	}
	return ""
}

func (m *GCEPersistentDiskVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *GCEPersistentDiskVolumeSource) GetPartition() int32 {
	if m != nil {
		return m.Partition
	}
	return 0
}

func (m *GCEPersistentDiskVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a volume that is populated with the contents of a git repository.
// Git repo volumes do not support ownership management.
// Git repo volumes support SELinux relabeling.
type GitRepoVolumeSource struct {
	// Repository URL
	Repository string `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	// Commit hash for the specified revision.
	Revision string `protobuf:"bytes,2,opt,name=revision" json:"revision,omitempty"`
	// Target directory name.
	// Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
	// git repository.  Otherwise, if specified, the volume will contain the git repository in
	// the subdirectory with the given name.
	Directory string `protobuf:"bytes,3,opt,name=directory" json:"directory,omitempty"`
}

func (m *GitRepoVolumeSource) Reset()                    { *m = GitRepoVolumeSource{} }
func (m *GitRepoVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*GitRepoVolumeSource) ProtoMessage()               {}
func (*GitRepoVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{60} }

func (m *GitRepoVolumeSource) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *GitRepoVolumeSource) GetRevision() string {
	if m != nil {
		return m.Revision
	}
	return ""
}

func (m *GitRepoVolumeSource) GetDirectory() string {
	if m != nil {
		return m.Directory
	}
	return ""
}

// Represents a Glusterfs mount that lasts the lifetime of a pod.
// Glusterfs volumes do not support ownership management or SELinux relabeling.
type GlusterfsVolumeSource struct {
	// EndpointsName is the endpoint name that details Glusterfs topology.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
	Endpoints string `protobuf:"bytes,1,opt,name=endpoints" json:"endpoints,omitempty"`
	// Path is the Glusterfs volume path.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
	// Defaults to false.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
	ReadOnly bool `protobuf:"varint,3,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *GlusterfsVolumeSource) Reset()                    { *m = GlusterfsVolumeSource{} }
func (m *GlusterfsVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*GlusterfsVolumeSource) ProtoMessage()               {}
func (*GlusterfsVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{61} }

func (m *GlusterfsVolumeSource) GetEndpoints() string {
	if m != nil {
		return m.Endpoints
	}
	return ""
}

func (m *GlusterfsVolumeSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *GlusterfsVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a Rados Block Device mount that lasts the lifetime of a pod.
// RBD volumes support ownership management and SELinux relabeling.
type RBDVolumeSource struct {
	// A collection of Ceph monitors.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
	Monitors []string `protobuf:"bytes,1,rep,name=monitors" json:"monitors,omitempty"`
	// The rados image name.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
	Image string `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	// Filesystem type of the volume that you want to mount.
	// Tip: Ensure that the filesystem type is supported by the host operating system.
	// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#rbd
	// TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType string `protobuf:"bytes,3,opt,name=fsType" json:"fsType,omitempty"`
	// The rados pool name.
	// Default is rbd.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it.
	Pool string `protobuf:"bytes,4,opt,name=pool" json:"pool,omitempty"`
	// The rados user name.
	// Default is admin.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
	User string `protobuf:"bytes,5,opt,name=user" json:"user,omitempty"`
	// Keyring is the path to key ring for RBDUser.
	// Default is /etc/ceph/keyring.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
	Keyring string `protobuf:"bytes,6,opt,name=keyring" json:"keyring,omitempty"`
	// SecretRef is name of the authentication secret for RBDUser. If provided
	// overrides keyring.
	// Default is nil.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
	SecretRef *ObjectReference `protobuf:"bytes,7,opt,name=secretRef" json:"secretRef,omitempty"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts.
	// Defaults to false.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
	ReadOnly bool `protobuf:"varint,8,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *RBDVolumeSource) Reset()                    { *m = RBDVolumeSource{} }
func (m *RBDVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*RBDVolumeSource) ProtoMessage()               {}
func (*RBDVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{62} }

func (m *RBDVolumeSource) GetMonitors() []string {
	if m != nil {
		return m.Monitors
	}
	return nil
}

func (m *RBDVolumeSource) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *RBDVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *RBDVolumeSource) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *RBDVolumeSource) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *RBDVolumeSource) GetKeyring() string {
	if m != nil {
		return m.Keyring
	}
	return ""
}

func (m *RBDVolumeSource) GetSecretRef() *ObjectReference {
	if m != nil {
		return m.SecretRef
	}
	return nil
}

func (m *RBDVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents an ISCSI disk.
// ISCSI volumes can only be mounted as read/write once.
// ISCSI volumes support ownership management and SELinux relabeling.
type ISCSIVolumeSource struct {
	// iSCSI target portal. The portal is either an IP or ip_addr:port if the port
	// is other than default (typically TCP ports 860 and 3260).
	TargetPortal string `protobuf:"bytes,1,opt,name=targetPortal" json:"targetPortal,omitempty"`
	// Target iSCSI Qualified Name.
	Iqn string `protobuf:"bytes,2,opt,name=iqn" json:"iqn,omitempty"`
	// iSCSI target lun number.
	Lun int32 `protobuf:"varint,3,opt,name=lun" json:"lun,omitempty"`
	// Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
	IscsiInterface string `protobuf:"bytes,4,opt,name=iscsiInterface" json:"iscsiInterface,omitempty"`
	// Filesystem type of the volume that you want to mount.
	// Tip: Ensure that the filesystem type is supported by the host operating system.
	// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	// More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#iscsi
	// TODO: how do we prevent errors in the filesystem from compromising the machine
	FsType string `protobuf:"bytes,5,opt,name=fsType" json:"fsType,omitempty"`
	// ReadOnly here will force the ReadOnly setting in VolumeMounts.
	// Defaults to false.
	ReadOnly bool `protobuf:"varint,6,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *ISCSIVolumeSource) Reset()                    { *m = ISCSIVolumeSource{} }
func (m *ISCSIVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*ISCSIVolumeSource) ProtoMessage()               {}
func (*ISCSIVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{63} }

func (m *ISCSIVolumeSource) GetTargetPortal() string {
	if m != nil {
		return m.TargetPortal
	}
	return ""
}

func (m *ISCSIVolumeSource) GetIqn() string {
	if m != nil {
		return m.Iqn
	}
	return ""
}

func (m *ISCSIVolumeSource) GetLun() int32 {
	if m != nil {
		return m.Lun
	}
	return 0
}

func (m *ISCSIVolumeSource) GetIscsiInterface() string {
	if m != nil {
		return m.IscsiInterface
	}
	return ""
}

func (m *ISCSIVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *ISCSIVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
type AzureFileVolumeSource struct {
	// the name of secret that contains Azure Storage Account Name and Key
	SecretName string `protobuf:"bytes,1,opt,name=secretName" json:"secretName,omitempty"`
	// Share Name
	ShareName string `protobuf:"bytes,2,opt,name=shareName" json:"shareName,omitempty"`
	// Defaults to false (read/write). ReadOnly here will force
	// the ReadOnly setting in VolumeMounts.
	ReadOnly bool `protobuf:"varint,3,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *AzureFileVolumeSource) Reset()                    { *m = AzureFileVolumeSource{} }
func (m *AzureFileVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*AzureFileVolumeSource) ProtoMessage()               {}
func (*AzureFileVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{64} }

func (m *AzureFileVolumeSource) GetSecretName() string {
	if m != nil {
		return m.SecretName
	}
	return ""
}

func (m *AzureFileVolumeSource) GetShareName() string {
	if m != nil {
		return m.ShareName
	}
	return ""
}

func (m *AzureFileVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a vSphere volume resource.
type VsphereVirtualDiskVolumeSource struct {
	// Path that identifies vSphere volume vmdk
	VolumePath string `protobuf:"bytes,1,opt,name=volumePath" json:"volumePath,omitempty"`
	// Filesystem type to mount.
	// Must be a filesystem type supported by the host operating system.
	// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType string `protobuf:"bytes,2,opt,name=fsType" json:"fsType,omitempty"`
}

func (m *VsphereVirtualDiskVolumeSource) Reset()                    { *m = VsphereVirtualDiskVolumeSource{} }
func (m *VsphereVirtualDiskVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*VsphereVirtualDiskVolumeSource) ProtoMessage()               {}
func (*VsphereVirtualDiskVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{65} }

func (m *VsphereVirtualDiskVolumeSource) GetVolumePath() string {
	if m != nil {
		return m.VolumePath
	}
	return ""
}

func (m *VsphereVirtualDiskVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

// Represents a Quobyte mount that lasts the lifetime of a pod.
// Quobyte volumes do not support ownership management or SELinux relabeling.
type QuobyteVolumeSource struct {
	// Registry represents a single or multiple Quobyte Registry services
	// specified as a string as host:port pair (multiple entries are separated with commas)
	// which acts as the central registry for volumes
	Registry string `protobuf:"bytes,1,opt,name=registry" json:"registry,omitempty"`
	// Volume is a string that references an already created Quobyte volume by name.
	Volume string `protobuf:"bytes,2,opt,name=volume" json:"volume,omitempty"`
	// ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
	// Defaults to false.
	ReadOnly bool `protobuf:"varint,3,opt,name=readOnly" json:"readOnly,omitempty"`
	// User to map volume access to
	// Defaults to serivceaccount user
	User string `protobuf:"bytes,4,opt,name=user" json:"user,omitempty"`
	// Group to map volume access to
	// Default is no group
	Group string `protobuf:"bytes,5,opt,name=group" json:"group,omitempty"`
}

func (m *QuobyteVolumeSource) Reset()                    { *m = QuobyteVolumeSource{} }
func (m *QuobyteVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*QuobyteVolumeSource) ProtoMessage()               {}
func (*QuobyteVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{66} }

func (m *QuobyteVolumeSource) GetRegistry() string {
	if m != nil {
		return m.Registry
	}
	return ""
}

func (m *QuobyteVolumeSource) GetVolume() string {
	if m != nil {
		return m.Volume
	}
	return ""
}

func (m *QuobyteVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

func (m *QuobyteVolumeSource) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *QuobyteVolumeSource) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
type AzureDiskVolumeSource struct {
	// The Name of the data disk in the blob storage
	DiskName string `protobuf:"bytes,1,opt,name=diskName" json:"diskName,omitempty"`
	// The URI the data disk in the blob storage
	DiskURI string `protobuf:"bytes,2,opt,name=diskURI" json:"diskURI,omitempty"`
	// Host Caching mode: None, Read Only, Read Write.
	CachingMode string `protobuf:"bytes,3,opt,name=cachingMode" json:"cachingMode,omitempty"`
	// Filesystem type to mount.
	// Must be a filesystem type supported by the host operating system.
	// Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	FsType string `protobuf:"bytes,4,opt,name=fsType" json:"fsType,omitempty"`
	// Defaults to false (read/write). ReadOnly here will force
	// the ReadOnly setting in VolumeMounts.
	ReadOnly bool `protobuf:"varint,5,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *AzureDiskVolumeSource) Reset()                    { *m = AzureDiskVolumeSource{} }
func (m *AzureDiskVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*AzureDiskVolumeSource) ProtoMessage()               {}
func (*AzureDiskVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{67} }

func (m *AzureDiskVolumeSource) GetDiskName() string {
	if m != nil {
		return m.DiskName
	}
	return ""
}

func (m *AzureDiskVolumeSource) GetDiskURI() string {
	if m != nil {
		return m.DiskURI
	}
	return ""
}

func (m *AzureDiskVolumeSource) GetCachingMode() string {
	if m != nil {
		return m.CachingMode
	}
	return ""
}

func (m *AzureDiskVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *AzureDiskVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
// Cinder volumes support ownership management and SELinux relabeling.
type CinderVolumeSource struct {
	// volume id used to identify the volume in cinder
	// More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
	VolumeID string `protobuf:"bytes,1,opt,name=volumeID" json:"volumeID,omitempty"`
	// Filesystem type to mount.
	// Must be a filesystem type supported by the host operating system.
	// Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
	// More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
	FsType string `protobuf:"bytes,2,opt,name=fsType" json:"fsType,omitempty"`
	// Optional: Defaults to false (read/write). ReadOnly here will force
	// the ReadOnly setting in VolumeMounts.
	// More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
	ReadOnly bool `protobuf:"varint,3,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *CinderVolumeSource) Reset()                    { *m = CinderVolumeSource{} }
func (m *CinderVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*CinderVolumeSource) ProtoMessage()               {}
func (*CinderVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{68} }

func (m *CinderVolumeSource) GetVolumeID() string {
	if m != nil {
		return m.VolumeID
	}
	return ""
}

func (m *CinderVolumeSource) GetFsType() string {
	if m != nil {
		return m.FsType
	}
	return ""
}

func (m *CinderVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
// Cephfs volumes do not support ownership management or SELinux relabeling.
type CephFSVolumeSource struct {
	// Required: Monitors is a collection of Ceph monitors
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
	Monitors []string `protobuf:"bytes,1,rep,name=monitors" json:"monitors,omitempty"`
	// Optional: Used as the mounted root, rather than the full Ceph tree, default is /
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Optional: User is the rados user name, default is admin
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
	User string `protobuf:"bytes,3,opt,name=user" json:"user,omitempty"`
	// Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
	SecretFile string `protobuf:"bytes,4,opt,name=secretFile" json:"secretFile,omitempty"`
	// Optional: SecretRef is reference to the authentication secret for User, default is empty.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
	SecretRef *ObjectReference `protobuf:"bytes,5,opt,name=secretRef" json:"secretRef,omitempty"`
	// Optional: Defaults to false (read/write). ReadOnly here will force
	// the ReadOnly setting in VolumeMounts.
	// More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
	ReadOnly bool `protobuf:"varint,6,opt,name=readOnly" json:"readOnly,omitempty"`
}

func (m *CephFSVolumeSource) Reset()                    { *m = CephFSVolumeSource{} }
func (m *CephFSVolumeSource) String() string            { return proto.CompactTextString(m) }
func (*CephFSVolumeSource) ProtoMessage()               {}
func (*CephFSVolumeSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{69} }

func (m *CephFSVolumeSource) GetMonitors() []string {
	if m != nil {
		return m.Monitors
	}
	return nil
}

func (m *CephFSVolumeSource) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *CephFSVolumeSource) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *CephFSVolumeSource) GetSecretFile() string {
	if m != nil {
		return m.SecretFile
	}
	return ""
}

func (m *CephFSVolumeSource) GetSecretRef() *ObjectReference {
	if m != nil {
		return m.SecretRef
	}
	return nil
}

func (m *CephFSVolumeSource) GetReadOnly() bool {
	if m != nil {
		return m.ReadOnly
	}
	return false
}

type DiskListRequest struct {
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
}

func (m *DiskListRequest) Reset()                    { *m = DiskListRequest{} }
func (m *DiskListRequest) String() string            { return proto.CompactTextString(m) }
func (*DiskListRequest) ProtoMessage()               {}
func (*DiskListRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{70} }

func (m *DiskListRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

type DiskListResponse struct {
	Status *appscode_dtypes.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Disks  []*Disk                 `protobuf:"bytes,2,rep,name=disks" json:"disks,omitempty"`
}

func (m *DiskListResponse) Reset()                    { *m = DiskListResponse{} }
func (m *DiskListResponse) String() string            { return proto.CompactTextString(m) }
func (*DiskListResponse) ProtoMessage()               {}
func (*DiskListResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{71} }

func (m *DiskListResponse) GetStatus() *appscode_dtypes.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DiskListResponse) GetDisks() []*Disk {
	if m != nil {
		return m.Disks
	}
	return nil
}

type DiskDescribeRequest struct {
	Cluster  string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Provider string `protobuf:"bytes,3,opt,name=provider" json:"provider,omitempty"`
}

func (m *DiskDescribeRequest) Reset()                    { *m = DiskDescribeRequest{} }
func (m *DiskDescribeRequest) String() string            { return proto.CompactTextString(m) }
func (*DiskDescribeRequest) ProtoMessage()               {}
func (*DiskDescribeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{72} }

func (m *DiskDescribeRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *DiskDescribeRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiskDescribeRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

type DiskDescribeResponse struct {
	Status *appscode_dtypes.Status `protobuf:"bytes,1,opt,name=status" json:"status,omitempty"`
	Disk   *Disk                   `protobuf:"bytes,2,opt,name=disk" json:"disk,omitempty"`
}

func (m *DiskDescribeResponse) Reset()                    { *m = DiskDescribeResponse{} }
func (m *DiskDescribeResponse) String() string            { return proto.CompactTextString(m) }
func (*DiskDescribeResponse) ProtoMessage()               {}
func (*DiskDescribeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{73} }

func (m *DiskDescribeResponse) GetStatus() *appscode_dtypes.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *DiskDescribeResponse) GetDisk() *Disk {
	if m != nil {
		return m.Disk
	}
	return nil
}

type DiskCreateRequest struct {
	Cluster  string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Name     string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Zone     string `protobuf:"bytes,3,opt,name=zone" json:"zone,omitempty"`
	DiskType string `protobuf:"bytes,4,opt,name=disk_type,json=diskType" json:"disk_type,omitempty"`
	SizeGb   int64  `protobuf:"varint,5,opt,name=size_gb,json=sizeGb" json:"size_gb,omitempty"`
}

func (m *DiskCreateRequest) Reset()                    { *m = DiskCreateRequest{} }
func (m *DiskCreateRequest) String() string            { return proto.CompactTextString(m) }
func (*DiskCreateRequest) ProtoMessage()               {}
func (*DiskCreateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{74} }

func (m *DiskCreateRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *DiskCreateRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiskCreateRequest) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *DiskCreateRequest) GetDiskType() string {
	if m != nil {
		return m.DiskType
	}
	return ""
}

func (m *DiskCreateRequest) GetSizeGb() int64 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

type DiskDeleteRequest struct {
	Cluster string `protobuf:"bytes,1,opt,name=cluster" json:"cluster,omitempty"`
	Uid     string `protobuf:"bytes,2,opt,name=uid" json:"uid,omitempty"`
}

func (m *DiskDeleteRequest) Reset()                    { *m = DiskDeleteRequest{} }
func (m *DiskDeleteRequest) String() string            { return proto.CompactTextString(m) }
func (*DiskDeleteRequest) ProtoMessage()               {}
func (*DiskDeleteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{75} }

func (m *DiskDeleteRequest) GetCluster() string {
	if m != nil {
		return m.Cluster
	}
	return ""
}

func (m *DiskDeleteRequest) GetUid() string {
	if m != nil {
		return m.Uid
	}
	return ""
}

type Disk struct {
	Name                  string                 `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Id                    string                 `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	Provider              string                 `protobuf:"bytes,3,opt,name=provider" json:"provider,omitempty"`
	SizeGb                int64                  `protobuf:"varint,4,opt,name=size_gb,json=sizeGb" json:"size_gb,omitempty"`
	Type                  string                 `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
	Zone                  string                 `protobuf:"bytes,6,opt,name=zone" json:"zone,omitempty"`
	Status                string                 `protobuf:"bytes,7,opt,name=status" json:"status,omitempty"`
	Users                 []string               `protobuf:"bytes,8,rep,name=users" json:"users,omitempty"`
	Kind                  string                 `protobuf:"bytes,9,opt,name=kind" json:"kind,omitempty"`
	Endpoint              string                 `protobuf:"bytes,10,opt,name=endpoint" json:"endpoint,omitempty"`
	Iops                  int64                  `protobuf:"varint,11,opt,name=iops" json:"iops,omitempty"`
	PersistentVolume      *PersistentVolume      `protobuf:"bytes,12,opt,name=persistent_volume,json=persistentVolume" json:"persistent_volume,omitempty"`
	PersistentVolumeClaim *PersistentVolumeClaim `protobuf:"bytes,13,opt,name=persistent_volume_claim,json=persistentVolumeClaim" json:"persistent_volume_claim,omitempty"`
}

func (m *Disk) Reset()                    { *m = Disk{} }
func (m *Disk) String() string            { return proto.CompactTextString(m) }
func (*Disk) ProtoMessage()               {}
func (*Disk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{76} }

func (m *Disk) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Disk) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Disk) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Disk) GetSizeGb() int64 {
	if m != nil {
		return m.SizeGb
	}
	return 0
}

func (m *Disk) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Disk) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Disk) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Disk) GetUsers() []string {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *Disk) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *Disk) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Disk) GetIops() int64 {
	if m != nil {
		return m.Iops
	}
	return 0
}

func (m *Disk) GetPersistentVolume() *PersistentVolume {
	if m != nil {
		return m.PersistentVolume
	}
	return nil
}

func (m *Disk) GetPersistentVolumeClaim() *PersistentVolumeClaim {
	if m != nil {
		return m.PersistentVolumeClaim
	}
	return nil
}

func init() {
	proto.RegisterType((*ListResourceRequest)(nil), "appscode.kubernetes.v1beta2.ListResourceRequest")
	proto.RegisterType((*ListResourceRequest_Ancestor)(nil), "appscode.kubernetes.v1beta2.ListResourceRequest.Ancestor")
	proto.RegisterType((*ListResourceResponse)(nil), "appscode.kubernetes.v1beta2.ListResourceResponse")
	proto.RegisterType((*DescribeResourceRequest)(nil), "appscode.kubernetes.v1beta2.DescribeResourceRequest")
	proto.RegisterType((*DescribeResourceResponse)(nil), "appscode.kubernetes.v1beta2.DescribeResourceResponse")
	proto.RegisterType((*UpdateResourceRequest)(nil), "appscode.kubernetes.v1beta2.UpdateResourceRequest")
	proto.RegisterType((*ConfigMapEditRequest)(nil), "appscode.kubernetes.v1beta2.ConfigMapEditRequest")
	proto.RegisterType((*SecretEditRequest)(nil), "appscode.kubernetes.v1beta2.SecretEditRequest")
	proto.RegisterType((*CopyResourceRequest)(nil), "appscode.kubernetes.v1beta2.CopyResourceRequest")
	proto.RegisterType((*CreateResourceRequest)(nil), "appscode.kubernetes.v1beta2.CreateResourceRequest")
	proto.RegisterType((*DeleteResourceRequest)(nil), "appscode.kubernetes.v1beta2.DeleteResourceRequest")
	proto.RegisterType((*KubeResourceList)(nil), "appscode.kubernetes.v1beta2.KubeResourceList")
	proto.RegisterType((*KubeResourceList_Apps)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Apps")
	proto.RegisterType((*KubeResourceList_ConfigMaps)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.ConfigMaps")
	proto.RegisterType((*KubeResourceList_DaemonSets)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.DaemonSets")
	proto.RegisterType((*KubeResourceList_Deployments)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Deployments")
	proto.RegisterType((*KubeResourceList_Jobs)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Jobs")
	proto.RegisterType((*KubeResourceList_Namespaces)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Namespaces")
	proto.RegisterType((*KubeResourceList_Nodes)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Nodes")
	proto.RegisterType((*KubeResourceList_StatefulSets)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.StatefulSets")
	proto.RegisterType((*KubeResourceList_Pods)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Pods")
	proto.RegisterType((*KubeResourceList_ReplicaSets)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.ReplicaSets")
	proto.RegisterType((*KubeResourceList_Services)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Services")
	proto.RegisterType((*KubeResourceList_Secrets)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Secrets")
	proto.RegisterType((*KubeResourceList_ReplicationControllers)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.ReplicationControllers")
	proto.RegisterType((*KubeResourceList_StorageClasses)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.StorageClasses")
	proto.RegisterType((*KubeResourceList_PersistentVolumes)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.PersistentVolumes")
	proto.RegisterType((*KubeResourceList_PersistentVolumeClaims)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.PersistentVolumeClaims")
	proto.RegisterType((*KubeResourceList_Alerts)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Alerts")
	proto.RegisterType((*KubeResourceList_Roles)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Roles")
	proto.RegisterType((*KubeResourceList_ClusterRoles)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.ClusterRoles")
	proto.RegisterType((*KubeResourceList_RoleBindings)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.RoleBindings")
	proto.RegisterType((*KubeResourceList_ClusterRoleBindings)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.ClusterRoleBindings")
	proto.RegisterType((*KubeResourceList_Certificates)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.Certificates")
	proto.RegisterType((*KubeResourceList_CronJobs)(nil), "appscode.kubernetes.v1beta2.KubeResourceList.CronJobs")
	proto.RegisterType((*KubeResource)(nil), "appscode.kubernetes.v1beta2.KubeResource")
	proto.RegisterType((*Meta)(nil), "appscode.kubernetes.v1beta2.Meta")
	proto.RegisterType((*KubeObject)(nil), "appscode.kubernetes.v1beta2.KubeObject")
	proto.RegisterType((*IcingaState)(nil), "appscode.kubernetes.v1beta2.IcingaState")
	proto.RegisterType((*App)(nil), "appscode.kubernetes.v1beta2.App")
	proto.RegisterType((*PodSpec)(nil), "appscode.kubernetes.v1beta2.PodSpec")
	proto.RegisterType((*PodSpec_Container)(nil), "appscode.kubernetes.v1beta2.PodSpec.Container")
	proto.RegisterType((*PodSpec_Container_VolumeMount)(nil), "appscode.kubernetes.v1beta2.PodSpec.Container.VolumeMount")
	proto.RegisterType((*PodSpec_Volume)(nil), "appscode.kubernetes.v1beta2.PodSpec.Volume")
	proto.RegisterType((*Raw)(nil), "appscode.kubernetes.v1beta2.Raw")
	proto.RegisterType((*ConfigMap)(nil), "appscode.kubernetes.v1beta2.ConfigMap")
	proto.RegisterType((*Job)(nil), "appscode.kubernetes.v1beta2.Job")
	proto.RegisterType((*Job_Status)(nil), "appscode.kubernetes.v1beta2.Job.Status")
	proto.RegisterType((*JobSpec)(nil), "appscode.kubernetes.v1beta2.JobSpec")
	proto.RegisterType((*Namespace)(nil), "appscode.kubernetes.v1beta2.Namespace")
	proto.RegisterType((*Namespace_Status)(nil), "appscode.kubernetes.v1beta2.Namespace.Status")
	proto.RegisterType((*Node)(nil), "appscode.kubernetes.v1beta2.Node")
	proto.RegisterType((*Node_Spec)(nil), "appscode.kubernetes.v1beta2.Node.Spec")
	proto.RegisterType((*Node_Status)(nil), "appscode.kubernetes.v1beta2.Node.Status")
	proto.RegisterType((*Node_Status_Capacity)(nil), "appscode.kubernetes.v1beta2.Node.Status.Capacity")
	proto.RegisterType((*Node_Status_NodeInfo)(nil), "appscode.kubernetes.v1beta2.Node.Status.NodeInfo")
	proto.RegisterType((*Pod)(nil), "appscode.kubernetes.v1beta2.Pod")
	proto.RegisterType((*Pod_Status)(nil), "appscode.kubernetes.v1beta2.Pod.Status")
	proto.RegisterType((*PersistentVolume)(nil), "appscode.kubernetes.v1beta2.PersistentVolume")
	proto.RegisterType((*PersistentVolume_PersistentVolumeSpec)(nil), "appscode.kubernetes.v1beta2.PersistentVolume.PersistentVolumeSpec")
	proto.RegisterType((*PersistentVolume_PersistentVolumeStatus)(nil), "appscode.kubernetes.v1beta2.PersistentVolume.PersistentVolumeStatus")
	proto.RegisterType((*PersistentVolumeClaim)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeClaim")
	proto.RegisterType((*PersistentVolumeClaim_PersistentVolumeClaimSpec)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeClaim.PersistentVolumeClaimSpec")
	proto.RegisterType((*PersistentVolumeClaim_PersistentVolumeClaimSpec_ResourceRequirements)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeClaim.PersistentVolumeClaimSpec.ResourceRequirements")
	proto.RegisterType((*PersistentVolumeClaim_PersistentVolumeClaimStatus)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeClaim.PersistentVolumeClaimStatus")
	proto.RegisterType((*ObjectReference)(nil), "appscode.kubernetes.v1beta2.ObjectReference")
	proto.RegisterType((*Service)(nil), "appscode.kubernetes.v1beta2.Service")
	proto.RegisterType((*Service_Spec)(nil), "appscode.kubernetes.v1beta2.Service.Spec")
	proto.RegisterType((*Service_Spec_Port)(nil), "appscode.kubernetes.v1beta2.Service.Spec.Port")
	proto.RegisterType((*Service_Status)(nil), "appscode.kubernetes.v1beta2.Service.Status")
	proto.RegisterType((*Service_Status_LoadBalancerIngress)(nil), "appscode.kubernetes.v1beta2.Service.Status.LoadBalancerIngress")
	proto.RegisterType((*Secret)(nil), "appscode.kubernetes.v1beta2.Secret")
	proto.RegisterType((*ReplicationController)(nil), "appscode.kubernetes.v1beta2.ReplicationController")
	proto.RegisterType((*ReplicationController_Spec)(nil), "appscode.kubernetes.v1beta2.ReplicationController.Spec")
	proto.RegisterType((*ReplicationController_Status)(nil), "appscode.kubernetes.v1beta2.ReplicationController.Status")
	proto.RegisterType((*ReplicaSet)(nil), "appscode.kubernetes.v1beta2.ReplicaSet")
	proto.RegisterType((*ReplicaSet_Spec)(nil), "appscode.kubernetes.v1beta2.ReplicaSet.Spec")
	proto.RegisterType((*ReplicaSet_Status)(nil), "appscode.kubernetes.v1beta2.ReplicaSet.Status")
	proto.RegisterType((*DaemonSet)(nil), "appscode.kubernetes.v1beta2.DaemonSet")
	proto.RegisterType((*DaemonSet_Spec)(nil), "appscode.kubernetes.v1beta2.DaemonSet.Spec")
	proto.RegisterType((*DaemonSet_Status)(nil), "appscode.kubernetes.v1beta2.DaemonSet.Status")
	proto.RegisterType((*Deployment)(nil), "appscode.kubernetes.v1beta2.Deployment")
	proto.RegisterType((*Deployment_Spec)(nil), "appscode.kubernetes.v1beta2.Deployment.Spec")
	proto.RegisterType((*Deployment_Status)(nil), "appscode.kubernetes.v1beta2.Deployment.Status")
	proto.RegisterType((*StatefulSet)(nil), "appscode.kubernetes.v1beta2.StatefulSet")
	proto.RegisterType((*StatefulSet_Spec)(nil), "appscode.kubernetes.v1beta2.StatefulSet.Spec")
	proto.RegisterType((*StatefulSet_Status)(nil), "appscode.kubernetes.v1beta2.StatefulSet.Status")
	proto.RegisterType((*StorageClass)(nil), "appscode.kubernetes.v1beta2.StorageClass")
	proto.RegisterType((*LabelSelector)(nil), "appscode.kubernetes.v1beta2.LabelSelector")
	proto.RegisterType((*Event)(nil), "appscode.kubernetes.v1beta2.Event")
	proto.RegisterType((*EventSource)(nil), "appscode.kubernetes.v1beta2.EventSource")
	proto.RegisterType((*Metrics)(nil), "appscode.kubernetes.v1beta2.Metrics")
	proto.RegisterType((*Metrics_DataPoint)(nil), "appscode.kubernetes.v1beta2.Metrics.DataPoint")
	proto.RegisterType((*PersistentVolumeRegisterRequest)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeRegisterRequest")
	proto.RegisterType((*PersistentVolumeUnRegisterRequest)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeUnRegisterRequest")
	proto.RegisterType((*PersistentVolumeClaimRegisterRequest)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeClaimRegisterRequest")
	proto.RegisterType((*PersistentVolumeClaimUnRegisterRequest)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeClaimUnRegisterRequest")
	proto.RegisterType((*Alert)(nil), "appscode.kubernetes.v1beta2.Alert")
	proto.RegisterType((*Alert_AlertSpec)(nil), "appscode.kubernetes.v1beta2.Alert.AlertSpec")
	proto.RegisterType((*Alert_AlertSpec_IcingaParam)(nil), "appscode.kubernetes.v1beta2.Alert.AlertSpec.IcingaParam")
	proto.RegisterType((*Alert_AlertSpec_NotifierParam)(nil), "appscode.kubernetes.v1beta2.Alert.AlertSpec.NotifierParam")
	proto.RegisterType((*Role)(nil), "appscode.kubernetes.v1beta2.Role")
	proto.RegisterType((*RoleBinding)(nil), "appscode.kubernetes.v1beta2.RoleBinding")
	proto.RegisterType((*ClusterRole)(nil), "appscode.kubernetes.v1beta2.ClusterRole")
	proto.RegisterType((*ClusterRoleBinding)(nil), "appscode.kubernetes.v1beta2.ClusterRoleBinding")
	proto.RegisterType((*Rule)(nil), "appscode.kubernetes.v1beta2.Rule")
	proto.RegisterType((*Subject)(nil), "appscode.kubernetes.v1beta2.Subject")
	proto.RegisterType((*CronJob)(nil), "appscode.kubernetes.v1beta2.CronJob")
	proto.RegisterType((*CronJob_Spec)(nil), "appscode.kubernetes.v1beta2.CronJob.Spec")
	proto.RegisterType((*CronJob_Status)(nil), "appscode.kubernetes.v1beta2.CronJob.Status")
	proto.RegisterType((*Certificate)(nil), "appscode.kubernetes.v1beta2.Certificate")
	proto.RegisterType((*Certificate_Spec)(nil), "appscode.kubernetes.v1beta2.Certificate.Spec")
	proto.RegisterType((*Certificate_Status)(nil), "appscode.kubernetes.v1beta2.Certificate.Status")
	proto.RegisterType((*Certificate_Status_ACMECertificateDetails)(nil), "appscode.kubernetes.v1beta2.Certificate.Status.ACMECertificateDetails")
	proto.RegisterType((*PersistentVolumeSource)(nil), "appscode.kubernetes.v1beta2.PersistentVolumeSource")
	proto.RegisterType((*AWSElasticBlockStoreVolumeSource)(nil), "appscode.kubernetes.v1beta2.AWSElasticBlockStoreVolumeSource")
	proto.RegisterType((*HostPathVolumeSource)(nil), "appscode.kubernetes.v1beta2.HostPathVolumeSource")
	proto.RegisterType((*NFSVolumeSource)(nil), "appscode.kubernetes.v1beta2.NFSVolumeSource")
	proto.RegisterType((*FCVolumeSource)(nil), "appscode.kubernetes.v1beta2.FCVolumeSource")
	proto.RegisterType((*FlexVolumeSource)(nil), "appscode.kubernetes.v1beta2.FlexVolumeSource")
	proto.RegisterType((*FlockerVolumeSource)(nil), "appscode.kubernetes.v1beta2.FlockerVolumeSource")
	proto.RegisterType((*GCEPersistentDiskVolumeSource)(nil), "appscode.kubernetes.v1beta2.GCEPersistentDiskVolumeSource")
	proto.RegisterType((*GitRepoVolumeSource)(nil), "appscode.kubernetes.v1beta2.GitRepoVolumeSource")
	proto.RegisterType((*GlusterfsVolumeSource)(nil), "appscode.kubernetes.v1beta2.GlusterfsVolumeSource")
	proto.RegisterType((*RBDVolumeSource)(nil), "appscode.kubernetes.v1beta2.RBDVolumeSource")
	proto.RegisterType((*ISCSIVolumeSource)(nil), "appscode.kubernetes.v1beta2.ISCSIVolumeSource")
	proto.RegisterType((*AzureFileVolumeSource)(nil), "appscode.kubernetes.v1beta2.AzureFileVolumeSource")
	proto.RegisterType((*VsphereVirtualDiskVolumeSource)(nil), "appscode.kubernetes.v1beta2.VsphereVirtualDiskVolumeSource")
	proto.RegisterType((*QuobyteVolumeSource)(nil), "appscode.kubernetes.v1beta2.QuobyteVolumeSource")
	proto.RegisterType((*AzureDiskVolumeSource)(nil), "appscode.kubernetes.v1beta2.AzureDiskVolumeSource")
	proto.RegisterType((*CinderVolumeSource)(nil), "appscode.kubernetes.v1beta2.CinderVolumeSource")
	proto.RegisterType((*CephFSVolumeSource)(nil), "appscode.kubernetes.v1beta2.CephFSVolumeSource")
	proto.RegisterType((*DiskListRequest)(nil), "appscode.kubernetes.v1beta2.DiskListRequest")
	proto.RegisterType((*DiskListResponse)(nil), "appscode.kubernetes.v1beta2.DiskListResponse")
	proto.RegisterType((*DiskDescribeRequest)(nil), "appscode.kubernetes.v1beta2.DiskDescribeRequest")
	proto.RegisterType((*DiskDescribeResponse)(nil), "appscode.kubernetes.v1beta2.DiskDescribeResponse")
	proto.RegisterType((*DiskCreateRequest)(nil), "appscode.kubernetes.v1beta2.DiskCreateRequest")
	proto.RegisterType((*DiskDeleteRequest)(nil), "appscode.kubernetes.v1beta2.DiskDeleteRequest")
	proto.RegisterType((*Disk)(nil), "appscode.kubernetes.v1beta2.Disk")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Clients service

type ClientsClient interface {
	List(ctx context.Context, in *ListResourceRequest, opts ...grpc.CallOption) (*ListResourceResponse, error)
	Describe(ctx context.Context, in *DescribeResourceRequest, opts ...grpc.CallOption) (*DescribeResourceResponse, error)
	Create(ctx context.Context, in *CreateResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	Delete(ctx context.Context, in *DeleteResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	Update(ctx context.Context, in *UpdateResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	Copy(ctx context.Context, in *CopyResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	// Followings are type specific actions api, that can be applied upon fixed resources.
	// TODO: (@sadlil) Consider seperating them.
	EditConfigMap(ctx context.Context, in *ConfigMapEditRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	EditSecret(ctx context.Context, in *SecretEditRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	RegisterPersistentVolume(ctx context.Context, in *PersistentVolumeRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	UnregisterPersistentVolume(ctx context.Context, in *PersistentVolumeUnRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	RegisterPersistentVolumeClaim(ctx context.Context, in *PersistentVolumeClaimRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	UnregisterPersistentVolumeClaim(ctx context.Context, in *PersistentVolumeClaimUnRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
}

type clientsClient struct {
	cc *grpc.ClientConn
}

func NewClientsClient(cc *grpc.ClientConn) ClientsClient {
	return &clientsClient{cc}
}

func (c *clientsClient) List(ctx context.Context, in *ListResourceRequest, opts ...grpc.CallOption) (*ListResourceResponse, error) {
	out := new(ListResourceResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) Describe(ctx context.Context, in *DescribeResourceRequest, opts ...grpc.CallOption) (*DescribeResourceResponse, error) {
	out := new(DescribeResourceResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/Describe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) Create(ctx context.Context, in *CreateResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) Delete(ctx context.Context, in *DeleteResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) Update(ctx context.Context, in *UpdateResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) Copy(ctx context.Context, in *CopyResourceRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/Copy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) EditConfigMap(ctx context.Context, in *ConfigMapEditRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/EditConfigMap", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) EditSecret(ctx context.Context, in *SecretEditRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/EditSecret", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) RegisterPersistentVolume(ctx context.Context, in *PersistentVolumeRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/RegisterPersistentVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) UnregisterPersistentVolume(ctx context.Context, in *PersistentVolumeUnRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/UnregisterPersistentVolume", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) RegisterPersistentVolumeClaim(ctx context.Context, in *PersistentVolumeClaimRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/RegisterPersistentVolumeClaim", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clientsClient) UnregisterPersistentVolumeClaim(ctx context.Context, in *PersistentVolumeClaimUnRegisterRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Clients/UnregisterPersistentVolumeClaim", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Clients service

type ClientsServer interface {
	List(context.Context, *ListResourceRequest) (*ListResourceResponse, error)
	Describe(context.Context, *DescribeResourceRequest) (*DescribeResourceResponse, error)
	Create(context.Context, *CreateResourceRequest) (*appscode_dtypes.VoidResponse, error)
	Delete(context.Context, *DeleteResourceRequest) (*appscode_dtypes.VoidResponse, error)
	Update(context.Context, *UpdateResourceRequest) (*appscode_dtypes.VoidResponse, error)
	Copy(context.Context, *CopyResourceRequest) (*appscode_dtypes.VoidResponse, error)
	// Followings are type specific actions api, that can be applied upon fixed resources.
	// TODO: (@sadlil) Consider seperating them.
	EditConfigMap(context.Context, *ConfigMapEditRequest) (*appscode_dtypes.VoidResponse, error)
	EditSecret(context.Context, *SecretEditRequest) (*appscode_dtypes.VoidResponse, error)
	RegisterPersistentVolume(context.Context, *PersistentVolumeRegisterRequest) (*appscode_dtypes.VoidResponse, error)
	UnregisterPersistentVolume(context.Context, *PersistentVolumeUnRegisterRequest) (*appscode_dtypes.VoidResponse, error)
	RegisterPersistentVolumeClaim(context.Context, *PersistentVolumeClaimRegisterRequest) (*appscode_dtypes.VoidResponse, error)
	UnregisterPersistentVolumeClaim(context.Context, *PersistentVolumeClaimUnRegisterRequest) (*appscode_dtypes.VoidResponse, error)
}

func RegisterClientsServer(s *grpc.Server, srv ClientsServer) {
	s.RegisterService(&_Clients_serviceDesc, srv)
}

func _Clients_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).List(ctx, req.(*ListResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/Describe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).Describe(ctx, req.(*DescribeResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).Create(ctx, req.(*CreateResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).Delete(ctx, req.(*DeleteResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).Update(ctx, req.(*UpdateResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_Copy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).Copy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/Copy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).Copy(ctx, req.(*CopyResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_EditConfigMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigMapEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).EditConfigMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/EditConfigMap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).EditConfigMap(ctx, req.(*ConfigMapEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_EditSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecretEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).EditSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/EditSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).EditSecret(ctx, req.(*SecretEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_RegisterPersistentVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PersistentVolumeRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).RegisterPersistentVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/RegisterPersistentVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).RegisterPersistentVolume(ctx, req.(*PersistentVolumeRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_UnregisterPersistentVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PersistentVolumeUnRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).UnregisterPersistentVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/UnregisterPersistentVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).UnregisterPersistentVolume(ctx, req.(*PersistentVolumeUnRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_RegisterPersistentVolumeClaim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PersistentVolumeClaimRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).RegisterPersistentVolumeClaim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/RegisterPersistentVolumeClaim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).RegisterPersistentVolumeClaim(ctx, req.(*PersistentVolumeClaimRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clients_UnregisterPersistentVolumeClaim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PersistentVolumeClaimUnRegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClientsServer).UnregisterPersistentVolumeClaim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Clients/UnregisterPersistentVolumeClaim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClientsServer).UnregisterPersistentVolumeClaim(ctx, req.(*PersistentVolumeClaimUnRegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Clients_serviceDesc = grpc.ServiceDesc{
	ServiceName: "appscode.kubernetes.v1beta2.Clients",
	HandlerType: (*ClientsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Clients_List_Handler,
		},
		{
			MethodName: "Describe",
			Handler:    _Clients_Describe_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Clients_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Clients_Delete_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Clients_Update_Handler,
		},
		{
			MethodName: "Copy",
			Handler:    _Clients_Copy_Handler,
		},
		{
			MethodName: "EditConfigMap",
			Handler:    _Clients_EditConfigMap_Handler,
		},
		{
			MethodName: "EditSecret",
			Handler:    _Clients_EditSecret_Handler,
		},
		{
			MethodName: "RegisterPersistentVolume",
			Handler:    _Clients_RegisterPersistentVolume_Handler,
		},
		{
			MethodName: "UnregisterPersistentVolume",
			Handler:    _Clients_UnregisterPersistentVolume_Handler,
		},
		{
			MethodName: "RegisterPersistentVolumeClaim",
			Handler:    _Clients_RegisterPersistentVolumeClaim_Handler,
		},
		{
			MethodName: "UnregisterPersistentVolumeClaim",
			Handler:    _Clients_UnregisterPersistentVolumeClaim_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "client.proto",
}

// Client API for Disks service

type DisksClient interface {
	List(ctx context.Context, in *DiskListRequest, opts ...grpc.CallOption) (*DiskListResponse, error)
	Describe(ctx context.Context, in *DiskDescribeRequest, opts ...grpc.CallOption) (*DiskDescribeResponse, error)
	Create(ctx context.Context, in *DiskCreateRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
	Delete(ctx context.Context, in *DiskDeleteRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error)
}

type disksClient struct {
	cc *grpc.ClientConn
}

func NewDisksClient(cc *grpc.ClientConn) DisksClient {
	return &disksClient{cc}
}

func (c *disksClient) List(ctx context.Context, in *DiskListRequest, opts ...grpc.CallOption) (*DiskListResponse, error) {
	out := new(DiskListResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Disks/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Describe(ctx context.Context, in *DiskDescribeRequest, opts ...grpc.CallOption) (*DiskDescribeResponse, error) {
	out := new(DiskDescribeResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Disks/Describe", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Create(ctx context.Context, in *DiskCreateRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Disks/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Delete(ctx context.Context, in *DiskDeleteRequest, opts ...grpc.CallOption) (*appscode_dtypes.VoidResponse, error) {
	out := new(appscode_dtypes.VoidResponse)
	err := grpc.Invoke(ctx, "/appscode.kubernetes.v1beta2.Disks/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Disks service

type DisksServer interface {
	List(context.Context, *DiskListRequest) (*DiskListResponse, error)
	Describe(context.Context, *DiskDescribeRequest) (*DiskDescribeResponse, error)
	Create(context.Context, *DiskCreateRequest) (*appscode_dtypes.VoidResponse, error)
	Delete(context.Context, *DiskDeleteRequest) (*appscode_dtypes.VoidResponse, error)
}

func RegisterDisksServer(s *grpc.Server, srv DisksServer) {
	s.RegisterService(&_Disks_serviceDesc, srv)
}

func _Disks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiskListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Disks/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).List(ctx, req.(*DiskListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Describe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiskDescribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Describe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Disks/Describe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Describe(ctx, req.(*DiskDescribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiskCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Disks/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Create(ctx, req.(*DiskCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DiskDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/appscode.kubernetes.v1beta2.Disks/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Delete(ctx, req.(*DiskDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Disks_serviceDesc = grpc.ServiceDesc{
	ServiceName: "appscode.kubernetes.v1beta2.Disks",
	HandlerType: (*DisksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _Disks_List_Handler,
		},
		{
			MethodName: "Describe",
			Handler:    _Disks_Describe_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Disks_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Disks_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "client.proto",
}

func init() { proto.RegisterFile("client.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 7159 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xdc, 0x3d, 0x5b, 0x8c, 0x24, 0xd7,
	0x55, 0x5b, 0xfd, 0x98, 0xee, 0x3e, 0x3d, 0xaf, 0xbd, 0x33, 0xbb, 0xdb, 0x6e, 0x3f, 0x76, 0x5d,
	0xf1, 0x73, 0xbd, 0xdb, 0xe3, 0x5d, 0xc7, 0xde, 0xf5, 0xda, 0xde, 0xdd, 0xd9, 0x99, 0xdd, 0x9d,
	0xd9, 0x97, 0xc7, 0x35, 0xbb, 0x76, 0x1e, 0x8e, 0xdb, 0xd5, 0x55, 0x77, 0x66, 0xca, 0x53, 0x5d,
	0x55, 0xae, 0xaa, 0x1e, 0x7b, 0xe2, 0x38, 0x81, 0x48, 0x51, 0x30, 0x26, 0x04, 0x42, 0x10, 0xf0,
	0x13, 0x09, 0x05, 0x10, 0x11, 0x89, 0x88, 0x10, 0x81, 0x1f, 0xff, 0x04, 0xf1, 0x83, 0x90, 0xc8,
	0x07, 0x02, 0x84, 0x84, 0x00, 0x21, 0x10, 0x09, 0xe1, 0x13, 0x09, 0x89, 0x2f, 0x74, 0x5f, 0x55,
	0xb7, 0xaa, 0x7b, 0xba, 0xab, 0x7a, 0x67, 0x0d, 0xca, 0x4f, 0xab, 0xee, 0xad, 0x7b, 0xce, 0xbd,
	0xf7, 0xdc, 0x73, 0xcf, 0xeb, 0x9e, 0x5b, 0x0d, 0x93, 0x86, 0x6d, 0x61, 0x27, 0x6c, 0x79, 0xbe,
	0x1b, 0xba, 0xe8, 0x7e, 0xdd, 0xf3, 0x02, 0xc3, 0x35, 0x71, 0x6b, 0xbb, 0xd7, 0xc1, 0xbe, 0x83,
	0x43, 0x1c, 0xb4, 0x76, 0x4e, 0x75, 0x70, 0xa8, 0x9f, 0x6e, 0x3e, 0xb0, 0xe9, 0xba, 0x9b, 0x36,
	0x5e, 0xd0, 0x3d, 0x6b, 0x41, 0x77, 0x1c, 0x37, 0xd4, 0x43, 0xcb, 0x75, 0x02, 0x06, 0xda, 0x7c,
	0x48, 0x80, 0xee, 0xf1, 0xfe, 0x68, 0xe2, 0xbd, 0x19, 0xee, 0x7a, 0x38, 0x58, 0xa0, 0xbf, 0xac,
	0x81, 0xfa, 0x51, 0x01, 0xe6, 0x6e, 0x58, 0x41, 0xa8, 0xe1, 0xc0, 0xed, 0xf9, 0x06, 0xd6, 0xf0,
	0xdb, 0x3d, 0x1c, 0x84, 0xa8, 0x01, 0x15, 0xc3, 0xee, 0x05, 0x21, 0xf6, 0x1b, 0xca, 0x31, 0xe5,
	0x89, 0x9a, 0x26, 0x8a, 0x08, 0x41, 0x89, 0x20, 0x68, 0x14, 0x68, 0x35, 0x7d, 0x46, 0x0f, 0x40,
	0xcd, 0xd1, 0xbb, 0x38, 0xf0, 0x74, 0x03, 0x37, 0x8a, 0xf4, 0x45, 0x5c, 0x81, 0x1e, 0x87, 0x19,
	0xcb, 0x31, 0xec, 0x9e, 0x89, 0xdb, 0x5d, 0x1c, 0xfa, 0x96, 0x11, 0x34, 0x4a, 0xc7, 0x94, 0x27,
	0xaa, 0xda, 0x34, 0xaf, 0xbe, 0xc9, 0x6a, 0xd1, 0x1d, 0xa8, 0xea, 0x8e, 0x81, 0x83, 0xd0, 0xf5,
	0x1b, 0xe5, 0x63, 0xca, 0x13, 0xf5, 0xd3, 0xcf, 0xb7, 0x86, 0xd0, 0xa6, 0x35, 0x60, 0xe0, 0xad,
	0x45, 0x8e, 0x40, 0x8b, 0x50, 0xa1, 0x47, 0x61, 0xda, 0xd6, 0x3b, 0xd8, 0x6e, 0x07, 0xd8, 0xc6,
	0x06, 0x41, 0x5e, 0xa1, 0x43, 0x9c, 0xa2, 0xb5, 0xeb, 0xbc, 0xb2, 0x79, 0x1a, 0xaa, 0x02, 0x38,
	0x9a, 0xa4, 0x22, 0x4d, 0x12, 0x41, 0x89, 0xcc, 0x49, 0x4c, 0x9c, 0x3c, 0xab, 0xdf, 0x54, 0x60,
	0x3e, 0x39, 0x8a, 0xc0, 0x73, 0x9d, 0x00, 0xa3, 0x05, 0x98, 0x08, 0x42, 0x3d, 0xec, 0x05, 0x14,
	0x45, 0xfd, 0xf4, 0x91, 0x78, 0x22, 0x6c, 0x15, 0x5a, 0xeb, 0xf4, 0xb5, 0xc6, 0x9b, 0xa1, 0xeb,
	0x50, 0xf3, 0x39, 0x92, 0x80, 0x76, 0x51, 0x3f, 0x7d, 0x72, 0xe8, 0xe4, 0xaf, 0xf7, 0x3a, 0x58,
	0x74, 0x4b, 0x87, 0x10, 0xc3, 0xab, 0x7f, 0xac, 0xc0, 0x91, 0x65, 0x1c, 0x18, 0xbe, 0x15, 0xb7,
	0xb9, 0x17, 0x2b, 0x2b, 0x48, 0x52, 0x8a, 0x49, 0x82, 0x66, 0xa1, 0xe8, 0xeb, 0xef, 0xd0, 0xf5,
	0xab, 0x69, 0xe4, 0x71, 0xd0, 0xfa, 0x4f, 0x0c, 0x5a, 0x7f, 0xf5, 0x1b, 0x0a, 0x34, 0xfa, 0x87,
	0x3d, 0x2e, 0x45, 0x2f, 0x43, 0x55, 0x50, 0x84, 0x13, 0xf4, 0xc9, 0xcc, 0x04, 0xd5, 0x22, 0x50,
	0xf5, 0x0f, 0x14, 0x38, 0x74, 0xc7, 0x33, 0xf5, 0xf0, 0x63, 0xa7, 0xe4, 0xe9, 0x98, 0x92, 0xf5,
	0xd3, 0xc7, 0x86, 0x8e, 0x5d, 0xd3, 0xdf, 0xa1, 0xb4, 0x56, 0xbf, 0x59, 0x84, 0xf9, 0x25, 0xd7,
	0xd9, 0xb0, 0x36, 0x6f, 0xea, 0xde, 0x65, 0xd3, 0x0a, 0x47, 0x0f, 0x36, 0x31, 0xb0, 0xc2, 0x5e,
	0x03, 0x2b, 0x4a, 0x03, 0xbb, 0x01, 0x45, 0xdd, 0x34, 0x1b, 0xa5, 0x63, 0xc5, 0x27, 0xea, 0xa7,
	0xcf, 0x0d, 0x1d, 0xd8, 0xa0, 0xb1, 0xb4, 0x16, 0x4d, 0xf3, 0xb2, 0x13, 0xfa, 0xbb, 0x1a, 0x41,
	0x83, 0xee, 0xc0, 0x44, 0x8f, 0xd2, 0xb7, 0x51, 0xa6, 0x08, 0x5f, 0xca, 0x8f, 0x90, 0xad, 0x0f,
	0xc3, 0xc9, 0x91, 0x91, 0x09, 0x9b, 0xd8, 0xc6, 0x21, 0x36, 0x1b, 0x13, 0xc7, 0x8a, 0x64, 0xc2,
	0xbc, 0xd8, 0x7c, 0x0e, 0xaa, 0x62, 0x04, 0x84, 0x5b, 0xb7, 0xf1, 0x2e, 0x27, 0x09, 0x79, 0x44,
	0xf3, 0x50, 0xde, 0xd1, 0xed, 0x9e, 0x20, 0x05, 0x2b, 0x9c, 0x2b, 0x9c, 0x55, 0x9a, 0xcf, 0x43,
	0x5d, 0xea, 0x28, 0x0f, 0xa8, 0xfa, 0x61, 0x11, 0x0e, 0xae, 0x63, 0xc3, 0xc7, 0xe1, 0xbd, 0x5a,
	0x93, 0x55, 0x79, 0x4d, 0xce, 0x0c, 0x25, 0x61, 0xdf, 0x40, 0x52, 0x0b, 0xa2, 0xa5, 0x16, 0xe4,
	0x5c, 0x4e, 0x6c, 0xff, 0xef, 0x57, 0xe3, 0xb7, 0x15, 0x98, 0x5b, 0x72, 0xbd, 0xdd, 0xf4, 0x86,
	0xbe, 0x00, 0x13, 0x5c, 0x5e, 0x30, 0x11, 0xf3, 0xf8, 0x48, 0x79, 0xf1, 0x72, 0xe7, 0x2d, 0x6c,
	0x84, 0x1a, 0x07, 0x43, 0xab, 0x50, 0x37, 0x71, 0x10, 0x5a, 0x0e, 0x55, 0xc2, 0x5c, 0xea, 0x64,
	0xc6, 0x22, 0xc3, 0xaa, 0x5f, 0x53, 0xe0, 0xd0, 0x92, 0x8f, 0xef, 0x5a, 0xec, 0xec, 0x97, 0x60,
	0x79, 0x07, 0x0e, 0x2d, 0xd3, 0x15, 0xfb, 0x98, 0xa5, 0xa0, 0xfa, 0xed, 0xa3, 0x30, 0x9b, 0xd6,
	0x75, 0x03, 0xf5, 0xf3, 0x0a, 0x94, 0xc8, 0x4c, 0x38, 0xd5, 0x4f, 0xe7, 0x52, 0x9e, 0xad, 0x45,
	0xcf, 0x0b, 0x56, 0x0e, 0x68, 0x14, 0x03, 0xfa, 0x2c, 0xd4, 0x0d, 0x2a, 0x66, 0xda, 0x5d, 0xdd,
	0x0b, 0xe8, 0x30, 0xeb, 0xa7, 0xcf, 0xe6, 0x43, 0x18, 0xc9, 0x29, 0x82, 0x16, 0x8c, 0xa8, 0x44,
	0x90, 0x9b, 0x3a, 0xee, 0xba, 0x4e, 0x3b, 0xc0, 0x21, 0xb3, 0x84, 0x72, 0x23, 0x5f, 0xa6, 0x08,
	0xd6, 0x71, 0x48, 0x91, 0x9b, 0x51, 0x09, 0x7d, 0x8e, 0x30, 0xa0, 0x67, 0xbb, 0xbb, 0x5d, 0xec,
	0x84, 0x41, 0x26, 0x23, 0xaa, 0x1f, 0x79, 0x8c, 0x60, 0xe5, 0x80, 0x26, 0xe3, 0x23, 0x24, 0x7e,
	0xcb, 0xed, 0x30, 0xf5, 0x9d, 0x9b, 0xc4, 0xd7, 0xdc, 0x0e, 0x25, 0x31, 0xc1, 0x80, 0x3e, 0x03,
	0x10, 0x2d, 0x7b, 0x40, 0xed, 0xb1, 0xdc, 0x44, 0xb8, 0x15, 0xc1, 0x13, 0x22, 0xc4, 0xd8, 0xd0,
	0x75, 0x28, 0x3b, 0xae, 0x89, 0x83, 0x46, 0x95, 0xa2, 0x7d, 0x26, 0x27, 0x5a, 0x02, 0xba, 0x72,
	0x40, 0x63, 0x38, 0x90, 0x0e, 0x53, 0xc4, 0x9e, 0xc0, 0x1b, 0x3d, 0x9b, 0x2d, 0x58, 0x8d, 0x22,
	0x3d, 0x97, 0x0f, 0xe9, 0x3a, 0x47, 0xc1, 0x97, 0x6c, 0x32, 0x90, 0xca, 0x84, 0xaa, 0x9e, 0x6b,
	0x06, 0x0d, 0x18, 0x87, 0xaa, 0x6b, 0xae, 0x49, 0xa9, 0x4a, 0x30, 0xa0, 0x37, 0x60, 0xd2, 0xc7,
	0x9e, 0x6d, 0x19, 0x3a, 0x1b, 0x6b, 0x7d, 0x9c, 0xf5, 0xd7, 0x18, 0x06, 0x3e, 0xd4, 0xba, 0x1f,
	0x17, 0xd1, 0x6d, 0xa8, 0x06, 0xd8, 0xdf, 0xb1, 0xc8, 0x9a, 0x4d, 0x52, 0xdc, 0xcf, 0xe5, 0xa4,
	0x03, 0x87, 0x5e, 0x39, 0xa0, 0x45, 0x98, 0xd0, 0x2b, 0x50, 0x09, 0xa8, 0x12, 0x09, 0x1a, 0x53,
	0x14, 0xe9, 0xb3, 0x79, 0x91, 0x52, 0xe0, 0x95, 0x03, 0x9a, 0xc0, 0x83, 0xbe, 0x04, 0x47, 0xf8,
	0xb8, 0x89, 0x30, 0x6d, 0x1b, 0xae, 0x13, 0xfa, 0xae, 0x6d, 0x63, 0x3f, 0x68, 0x4c, 0xd3, 0x2e,
	0x96, 0xc7, 0xa2, 0x09, 0x41, 0xb6, 0x14, 0xe3, 0x5a, 0x39, 0xa0, 0x1d, 0xf6, 0x07, 0xbe, 0x41,
	0x9b, 0x30, 0x43, 0x1c, 0x09, 0x7d, 0x13, 0xb7, 0x0d, 0x5b, 0x0f, 0x02, 0x1c, 0x34, 0x66, 0x68,
	0xc7, 0x2f, 0xe6, 0x65, 0x1c, 0x8a, 0x64, 0x89, 0xe1, 0x58, 0x39, 0xa0, 0x4d, 0x07, 0x89, 0x1a,
	0xe4, 0x01, 0xf2, 0xb0, 0x1f, 0x58, 0x41, 0x88, 0x9d, 0xb0, 0xbd, 0xe3, 0xda, 0xbd, 0x2e, 0x0e,
	0x1a, 0xb3, 0xb4, 0xaf, 0x0b, 0x39, 0x59, 0x29, 0xc2, 0xf3, 0x2a, 0x43, 0xb3, 0x72, 0x40, 0x3b,
	0xe8, 0xa5, 0x2b, 0xd1, 0xcf, 0x29, 0xd0, 0xe8, 0xeb, 0x92, 0xcc, 0xd2, 0xea, 0x06, 0x8d, 0x83,
	0xe3, 0x50, 0x37, 0xdd, 0xf1, 0x12, 0xc5, 0x45, 0xa8, 0xeb, 0x0d, 0x7c, 0x83, 0x6e, 0xc1, 0x84,
	0x6e, 0x63, 0x3f, 0x0c, 0x1a, 0x88, 0xf6, 0xf7, 0xc9, 0x9c, 0xc2, 0x9e, 0xc2, 0xae, 0x1c, 0xd0,
	0x38, 0x16, 0x22, 0x31, 0x7c, 0xd7, 0xc6, 0x41, 0x63, 0x6e, 0x1c, 0x89, 0xa1, 0x11, 0x50, 0x22,
	0x31, 0x28, 0x0e, 0x22, 0x31, 0xb8, 0x06, 0x6c, 0x33, 0xa4, 0xf3, 0xe3, 0x48, 0x8c, 0x25, 0x86,
	0x42, 0xe0, 0x9e, 0x34, 0xa4, 0x32, 0xe9, 0x82, 0xa0, 0x6e, 0x77, 0x2c, 0xc7, 0xb4, 0x9c, 0xcd,
	0xa0, 0x71, 0x68, 0x9c, 0x2e, 0x08, 0xae, 0x4b, 0x1c, 0x03, 0xe9, 0xc2, 0x97, 0xca, 0xe8, 0x1d,
	0x38, 0x24, 0xcf, 0x22, 0xee, 0xea, 0x30, 0xed, 0x6a, 0x71, 0xec, 0xd9, 0x48, 0x3d, 0xce, 0x19,
	0xfd, 0xd5, 0xe8, 0x4d, 0x98, 0x34, 0xb0, 0x1f, 0x5a, 0x1b, 0x64, 0x57, 0xe1, 0xa0, 0x71, 0x64,
	0x2c, 0xea, 0x49, 0x18, 0x28, 0xf5, 0xa4, 0x32, 0xba, 0x03, 0x35, 0xc3, 0x77, 0x9d, 0x36, 0x55,
	0x65, 0x8d, 0x71, 0xc4, 0xd8, 0x92, 0xef, 0x3a, 0x5c, 0x9d, 0x55, 0x0d, 0xfe, 0xdc, 0x3c, 0x0f,
	0x25, 0x62, 0x45, 0xa0, 0xe7, 0xa0, 0x6c, 0x85, 0xb8, 0x4b, 0xfc, 0xd4, 0xe2, 0x48, 0xfb, 0x6a,
	0xd1, 0xf3, 0x34, 0xd6, 0xbc, 0x79, 0x0d, 0x20, 0x36, 0x1a, 0xd0, 0x8b, 0x49, 0x2c, 0x8f, 0x65,
	0x73, 0x8a, 0x24, 0x5c, 0xb1, 0x8d, 0x90, 0x0f, 0x57, 0x04, 0x27, 0x70, 0xdd, 0x80, 0xba, 0x64,
	0x12, 0xa0, 0x97, 0x92, 0xc8, 0x86, 0x5b, 0xb7, 0x31, 0xa0, 0xc0, 0x76, 0x1e, 0x4a, 0x84, 0x5a,
	0xf9, 0xa8, 0x74, 0xcd, 0xed, 0x48, 0x33, 0x8b, 0x15, 0x7f, 0xbe, 0x99, 0x45, 0x70, 0x02, 0xd7,
	0x45, 0x28, 0x53, 0x6d, 0x8f, 0xce, 0x24, 0xd1, 0x3c, 0x3c, 0x1c, 0x8d, 0x6b, 0x46, 0x18, 0x6e,
	0xc1, 0xa4, 0xac, 0xda, 0xd1, 0xf9, 0x24, 0xa2, 0x27, 0x86, 0x7b, 0x4e, 0x31, 0xa4, 0x44, 0x1d,
	0xa2, 0xd0, 0xf3, 0x51, 0x67, 0xcd, 0x35, 0xa5, 0xb5, 0x92, 0xd4, 0x77, 0xbe, 0xb5, 0x8a, 0x01,
	0x05, 0xb6, 0x2b, 0x50, 0x15, 0x0a, 0x1b, 0x9d, 0x4b, 0xa2, 0x7a, 0x64, 0x84, 0x4f, 0x48, 0xa1,
	0x04, 0x9e, 0x65, 0xa8, 0x70, 0x1d, 0x8d, 0x9e, 0x4f, 0xa2, 0xf9, 0x44, 0x06, 0xd7, 0x52, 0x60,
	0xe9, 0xc0, 0xe1, 0xc1, 0x6a, 0x18, 0xad, 0x24, 0x91, 0x9e, 0xce, 0x32, 0xcd, 0x24, 0x0e, 0xd1,
	0xc7, 0x2b, 0x30, 0x9d, 0xd4, 0xb8, 0xe8, 0x42, 0x12, 0xf7, 0x93, 0x23, 0x56, 0x34, 0x86, 0x15,
	0x28, 0x3f, 0x05, 0x07, 0xfb, 0x14, 0x2b, 0x5a, 0x4a, 0x62, 0x1d, 0x1e, 0xe9, 0x4b, 0x83, 0x4b,
	0x04, 0x19, 0xac, 0x39, 0xf3, 0x11, 0x64, 0x20, 0x0e, 0xd1, 0xc7, 0x25, 0x98, 0x60, 0xda, 0x12,
	0x9d, 0x4d, 0xe2, 0x54, 0x87, 0x8b, 0x35, 0x02, 0x23, 0x6d, 0x33, 0xa6, 0xb6, 0x72, 0x6d, 0x33,
	0x02, 0x22, 0x6d, 0x33, 0x59, 0x1f, 0xe6, 0xdb, 0x66, 0x12, 0xa4, 0x84, 0x2f, 0xa1, 0x73, 0x72,
	0xe1, 0x93, 0x20, 0x05, 0xbe, 0xd7, 0x61, 0x6e, 0x80, 0x86, 0x43, 0x97, 0x93, 0x68, 0x17, 0xb2,
	0x0e, 0x33, 0x85, 0x9d, 0xcc, 0x5e, 0xd6, 0x5f, 0xf9, 0x66, 0x1f, 0x43, 0x4a, 0xdb, 0x5a, 0x28,
	0xb0, 0x7c, 0xdb, 0x9a, 0x43, 0x71, 0x3c, 0x97, 0x20, 0x0e, 0xb0, 0xaa, 0x7f, 0x35, 0x0d, 0x93,
	0xb2, 0x9a, 0x1c, 0xe8, 0xa1, 0x7f, 0x12, 0x8a, 0xba, 0xe7, 0x71, 0x07, 0x7d, 0xa4, 0x5e, 0x5c,
	0x39, 0xa0, 0x91, 0xe6, 0xe8, 0x2a, 0x40, 0xec, 0x8d, 0x73, 0x67, 0x3c, 0xa3, 0x3a, 0x5c, 0x39,
	0xa0, 0xd5, 0x22, 0xd7, 0x9b, 0x20, 0x8a, 0x3d, 0x6f, 0xee, 0x78, 0x67, 0xd4, 0x85, 0x04, 0x51,
	0xe4, 0x66, 0xa3, 0x55, 0x80, 0xd8, 0x2b, 0xe6, 0x4e, 0x76, 0x56, 0x3d, 0x48, 0x1d, 0xf6, 0xa8,
	0x44, 0x48, 0xf2, 0x96, 0xdb, 0xe1, 0x0e, 0xf5, 0x48, 0x25, 0x48, 0x48, 0xf2, 0x96, 0xdb, 0x41,
	0x57, 0xe4, 0x28, 0x4a, 0x25, 0xc3, 0x44, 0x22, 0xd5, 0x47, 0x26, 0x12, 0xc7, 0x5b, 0xce, 0x40,
	0x89, 0x78, 0xb9, 0xdc, 0x51, 0x1e, 0xad, 0xf6, 0x88, 0xa3, 0x49, 0x00, 0xd0, 0x4d, 0x98, 0x94,
	0xbd, 0x62, 0xee, 0x14, 0x67, 0x56, 0x77, 0xc4, 0xaf, 0x94, 0x5c, 0x60, 0x42, 0x05, 0xcf, 0x35,
	0xb9, 0x03, 0x3c, 0x52, 0xd9, 0x11, 0x2a, 0x78, 0xae, 0x89, 0xae, 0x41, 0x5d, 0xf2, 0x76, 0xb9,
	0xb3, 0x9b, 0x55, 0xc7, 0x91, 0x75, 0x88, 0x5d, 0x5b, 0x74, 0x91, 0xf8, 0xa0, 0x54, 0x69, 0x71,
	0xc7, 0x36, 0x93, 0x82, 0x63, 0x2e, 0x27, 0x7d, 0x44, 0x2f, 0xc1, 0x04, 0xf3, 0x3e, 0xb9, 0x13,
	0x9b, 0x45, 0xb5, 0x11, 0x17, 0x84, 0x01, 0xa1, 0x6d, 0x38, 0x3c, 0xd8, 0x63, 0xe5, 0x0e, 0xeb,
	0x18, 0x4a, 0x6d, 0xe5, 0x80, 0x76, 0x68, 0xa0, 0x7b, 0x8a, 0xd6, 0x60, 0x2a, 0xe1, 0x9d, 0x72,
	0xdf, 0x34, 0xbb, 0x72, 0x63, 0x31, 0x8c, 0xb8, 0x8c, 0x5e, 0x87, 0x83, 0x7d, 0x3e, 0x21, 0xf7,
	0x42, 0xf3, 0x29, 0xb7, 0x95, 0x03, 0xda, 0x6c, 0xda, 0xeb, 0x43, 0x36, 0x1c, 0xd9, 0xc3, 0xe3,
	0xe4, 0x0e, 0xe7, 0x18, 0x1a, 0x8e, 0x50, 0x67, 0xa0, 0x7b, 0x49, 0x64, 0x22, 0xf5, 0x0b, 0xb9,
	0xe3, 0x96, 0x41, 0xd3, 0x11, 0xe7, 0x8f, 0x82, 0x90, 0x1d, 0x45, 0xdc, 0x25, 0xee, 0x90, 0x8d,
	0xd6, 0x70, 0x64, 0x47, 0x11, 0x00, 0xb2, 0xa3, 0x64, 0x7f, 0x8b, 0xbb, 0x59, 0x99, 0x35, 0x1b,
	0xd9, 0x51, 0x92, 0x37, 0x45, 0xd0, 0xc9, 0x6e, 0x1b, 0xf7, 0xa2, 0x32, 0x2b, 0x36, 0x1a, 0xf8,
	0x89, 0x8b, 0xc8, 0x80, 0xf9, 0x41, 0xde, 0x20, 0xf7, 0x9e, 0xf2, 0x2a, 0xb6, 0x95, 0x03, 0x1a,
	0xea, 0x77, 0xfd, 0xd0, 0x0d, 0xa8, 0x4b, 0x7e, 0x5a, 0xe3, 0xbe, 0x2c, 0x14, 0x88, 0xdb, 0x53,
	0x0a, 0xc4, 0x45, 0xb4, 0x08, 0x55, 0xe1, 0xe5, 0x35, 0x9a, 0x19, 0xb6, 0x34, 0x57, 0x6e, 0x64,
	0x4b, 0x73, 0x97, 0x0e, 0x9d, 0x83, 0x09, 0xbc, 0x43, 0x03, 0xa9, 0x28, 0x83, 0xcd, 0x73, 0x99,
	0x34, 0xd5, 0x38, 0x84, 0x88, 0xb1, 0xcf, 0xe5, 0x88, 0xb1, 0x27, 0x14, 0xea, 0xdf, 0x17, 0xa1,
	0x74, 0x13, 0x87, 0x7a, 0x14, 0x13, 0x57, 0xa4, 0x00, 0xfe, 0xf0, 0xe3, 0xa1, 0x07, 0x01, 0x02,
	0x6c, 0x6f, 0xb4, 0x6d, 0xcb, 0xd9, 0x0e, 0x44, 0x90, 0x9d, 0xd4, 0xdc, 0x20, 0x15, 0xe8, 0x49,
	0x98, 0x15, 0xbd, 0xb4, 0x77, 0xc8, 0x06, 0x70, 0x1d, 0x1e, 0x70, 0x9f, 0x11, 0xf5, 0xaf, 0xb2,
	0x6a, 0x82, 0xc9, 0xa0, 0x67, 0x10, 0x66, 0x5b, 0x67, 0x8a, 0xae, 0xa8, 0xd5, 0x78, 0xcd, 0x62,
	0x88, 0x1e, 0x02, 0xd8, 0xc4, 0x0e, 0xf6, 0xd9, 0x69, 0xc7, 0x04, 0x7d, 0x2d, 0xd5, 0xa0, 0xcb,
	0x30, 0x41, 0x8f, 0xd8, 0x83, 0x46, 0x25, 0x83, 0x99, 0x4b, 0x66, 0xdb, 0xba, 0x41, 0xdb, 0xf3,
	0xb3, 0x23, 0x06, 0x8c, 0x6e, 0x43, 0x5d, 0xca, 0x6c, 0x68, 0x54, 0x33, 0xd8, 0xb4, 0x14, 0xd7,
	0x62, 0x0c, 0xc4, 0x10, 0xca, 0x68, 0x9a, 0xcf, 0x43, 0x5d, 0xea, 0x2c, 0xd7, 0xd1, 0xd3, 0x79,
	0x98, 0x4d, 0xe3, 0xce, 0x75, 0xfe, 0x64, 0x03, 0xc4, 0xc7, 0x3e, 0xf7, 0xfc, 0x00, 0xa5, 0x0b,
	0xf5, 0x55, 0xc3, 0x72, 0x36, 0x75, 0xaa, 0x80, 0xd1, 0x34, 0x14, 0x5e, 0xbe, 0x4e, 0x7b, 0x2a,
	0x6b, 0x85, 0x97, 0xaf, 0x93, 0xee, 0x5f, 0xd3, 0x7d, 0x87, 0xec, 0xe6, 0x02, 0xad, 0x14, 0x45,
	0xd4, 0x24, 0x76, 0xa2, 0x15, 0x5a, 0x86, 0x6e, 0xd3, 0x9e, 0xca, 0x5a, 0x54, 0x26, 0x50, 0x77,
	0x9c, 0x6d, 0xc7, 0x7d, 0x87, 0xf1, 0x4e, 0x59, 0x13, 0x45, 0xf5, 0x77, 0x8b, 0x50, 0x5c, 0xf4,
	0xbc, 0x7b, 0x7e, 0x3a, 0xfe, 0x1c, 0x33, 0x26, 0xcb, 0xd9, 0xb5, 0x35, 0x33, 0x27, 0x17, 0xa1,
	0xcc, 0x36, 0xc6, 0x04, 0xe5, 0xa3, 0xa7, 0x46, 0x99, 0xa1, 0x2d, 0xba, 0x6b, 0x18, 0x03, 0x31,
	0xc8, 0xd4, 0xb6, 0xa8, 0xa4, 0xb7, 0x05, 0x79, 0xcd, 0x85, 0xa5, 0xe5, 0x51, 0xdb, 0xaa, 0xa6,
	0xd5, 0x78, 0xcd, 0xaa, 0x87, 0xae, 0xc3, 0xa4, 0x45, 0xd7, 0xa3, 0x4d, 0x4d, 0xa0, 0x4c, 0xb6,
	0x93, 0xb4, 0x80, 0x5a, 0xdd, 0x8a, 0x0b, 0xcd, 0xb3, 0x00, 0xf1, 0xf8, 0x72, 0x31, 0xe1, 0x2f,
	0x4f, 0x40, 0x65, 0xcd, 0x35, 0xd7, 0x3d, 0x6c, 0xa0, 0xcb, 0x50, 0x11, 0x91, 0x63, 0x25, 0x03,
	0x55, 0x38, 0x58, 0x8b, 0xbb, 0xa3, 0x02, 0x16, 0xdd, 0xa2, 0x96, 0x7a, 0xa8, 0x5b, 0x0e, 0xf6,
	0x83, 0x46, 0x81, 0x62, 0x6a, 0x65, 0xc2, 0xb4, 0x24, 0xc0, 0x34, 0x09, 0x03, 0x7a, 0x03, 0xa6,
	0x89, 0xb5, 0x19, 0xe5, 0xed, 0x10, 0x61, 0x36, 0xfa, 0x78, 0x5b, 0xe0, 0x24, 0x06, 0xab, 0x48,
	0xee, 0xe1, 0xeb, 0x37, 0xe5, 0xc8, 0x75, 0xe8, 0x69, 0x98, 0xe7, 0xd6, 0x5b, 0x5b, 0x37, 0x0c,
	0xb7, 0xe7, 0x84, 0x6d, 0x89, 0xcd, 0x10, 0x7f, 0xb7, 0xc8, 0x5e, 0x11, 0x13, 0x1a, 0xdd, 0x0f,
	0x35, 0x3a, 0x22, 0xda, 0x8c, 0xa5, 0xb8, 0x54, 0x49, 0x05, 0x7d, 0x79, 0x02, 0x90, 0xd5, 0x25,
	0x36, 0x95, 0xd7, 0xb3, 0x89, 0x59, 0xcc, 0x8e, 0x34, 0xd8, 0x71, 0xf7, 0x2c, 0x7d, 0xb3, 0xd6,
	0xb3, 0x6d, 0x1e, 0x09, 0x69, 0x5e, 0x04, 0xd4, 0x3f, 0xc2, 0x5c, 0x62, 0xe8, 0x57, 0x0b, 0x50,
	0x8b, 0x08, 0x37, 0x50, 0x4f, 0xcc, 0x43, 0x99, 0xf6, 0x2b, 0x60, 0x69, 0x81, 0xec, 0x6b, 0xc3,
	0xed, 0x76, 0x75, 0xc7, 0x64, 0x04, 0xad, 0x69, 0x51, 0x19, 0xb5, 0x61, 0x8a, 0x9b, 0x57, 0x5d,
	0x32, 0xe9, 0x20, 0x53, 0x92, 0x47, 0xdf, 0x2a, 0x72, 0xce, 0xb8, 0x49, 0x50, 0x68, 0x93, 0x3b,
	0x71, 0x21, 0x68, 0x7e, 0x0e, 0xea, 0xd2, 0xcb, 0x81, 0xa3, 0xbe, 0x1f, 0x6a, 0x3e, 0xd6, 0xcd,
	0xb6, 0xeb, 0xd8, 0xbb, 0x74, 0xe4, 0x55, 0xad, 0x4a, 0x2a, 0x5e, 0x76, 0xec, 0x5d, 0xb2, 0xb9,
	0xe8, 0xc8, 0xda, 0x9e, 0x1e, 0x6e, 0x09, 0x49, 0x41, 0x6b, 0xd6, 0xf4, 0x70, 0xab, 0xf9, 0x3c,
	0x4c, 0x70, 0x9b, 0x71, 0x0f, 0xcc, 0x5b, 0x6e, 0xc0, 0x61, 0x19, 0x4d, 0xaa, 0xa4, 0x82, 0x80,
	0xaa, 0xa7, 0xa0, 0xa8, 0xe9, 0xef, 0xa0, 0xc3, 0x30, 0xb1, 0xe1, 0xfa, 0x5d, 0x3d, 0xe4, 0x90,
	0xbc, 0x44, 0xf0, 0x99, 0x7a, 0xa8, 0x0b, 0xa9, 0x45, 0x9e, 0xd5, 0x1f, 0x2a, 0x74, 0x05, 0xb8,
	0x7f, 0xf9, 0x2c, 0x94, 0xba, 0x38, 0xd4, 0x79, 0xf2, 0xc0, 0xc3, 0x23, 0x15, 0x94, 0x46, 0x9b,
	0xa3, 0xe5, 0x08, 0x31, 0xa1, 0xf4, 0xd3, 0xd9, 0x3c, 0xdb, 0xd6, 0xb2, 0x1e, 0xea, 0x8c, 0xa9,
	0x29, 0x74, 0xf3, 0x0c, 0xd4, 0xa2, 0xaa, 0x5c, 0x72, 0xe0, 0x3f, 0x0b, 0x50, 0x24, 0xc6, 0xce,
	0x98, 0xa3, 0x9f, 0x8d, 0x7d, 0xfa, 0x1a, 0x13, 0xb0, 0xe7, 0xa0, 0x1c, 0x8b, 0xf1, 0x51, 0xa2,
	0xf9, 0x9a, 0xdb, 0x21, 0xac, 0xa3, 0x31, 0x10, 0x9a, 0x81, 0xc1, 0x92, 0xbc, 0x4a, 0x19, 0xbc,
	0xb9, 0x6b, 0x6e, 0x27, 0x95, 0xf4, 0xd5, 0xfc, 0x96, 0x02, 0x13, 0xac, 0x8a, 0x9a, 0x41, 0xa1,
	0xee, 0x87, 0xed, 0xd0, 0xe2, 0x6c, 0x50, 0xd4, 0x6a, 0xb4, 0xe6, 0xb6, 0xd5, 0xa5, 0x59, 0x89,
	0x86, 0xdb, 0xf5, 0x6c, 0x4c, 0xfd, 0x2d, 0xda, 0xa6, 0x40, 0xdb, 0x4c, 0xc7, 0xd5, 0xb4, 0xe1,
	0x61, 0x98, 0xd0, 0x8d, 0xd0, 0xda, 0xc1, 0x5c, 0x09, 0xf2, 0x12, 0x51, 0x59, 0x41, 0xcf, 0x30,
	0x30, 0x36, 0xb1, 0xc9, 0x95, 0x60, 0x5c, 0x41, 0xd9, 0x48, 0xb7, 0x6c, 0x6c, 0x52, 0x31, 0x51,
	0xd6, 0x78, 0x49, 0xfd, 0xba, 0x02, 0x15, 0x3e, 0x69, 0x74, 0x0c, 0xea, 0x9e, 0xee, 0xeb, 0xb6,
	0x8d, 0x6d, 0x2b, 0xe8, 0x72, 0x9d, 0x2c, 0x57, 0x91, 0x16, 0xf1, 0x68, 0x02, 0xae, 0xa0, 0xe5,
	0x2a, 0x74, 0x11, 0xaa, 0x21, 0xee, 0x7a, 0x36, 0xd1, 0x24, 0x59, 0x08, 0xce, 0xf7, 0xaa, 0x16,
	0x41, 0xa9, 0xdf, 0x51, 0xa0, 0x16, 0xc5, 0x07, 0xc6, 0x65, 0x83, 0xcb, 0xd1, 0xc2, 0x65, 0xc9,
	0x5d, 0x8c, 0xba, 0x4b, 0x2f, 0xdf, 0x43, 0xd1, 0xea, 0xcd, 0x43, 0xd9, 0xdb, 0xd2, 0x03, 0xb1,
	0x7f, 0x59, 0x41, 0xfd, 0xaf, 0x09, 0x28, 0x11, 0xa9, 0x39, 0xee, 0x30, 0xcf, 0x41, 0x29, 0xf0,
	0xb0, 0xc1, 0x07, 0xf9, 0xd8, 0xc8, 0x80, 0x47, 0x8b, 0xd2, 0x8a, 0xc2, 0x10, 0xe1, 0x61, 0x05,
	0xed, 0xae, 0x4e, 0x4d, 0x9a, 0x22, 0x13, 0x4b, 0x56, 0x70, 0x93, 0x96, 0xd1, 0xc5, 0x14, 0xe3,
	0x3e, 0x91, 0x01, 0x75, 0x32, 0x5d, 0xf1, 0x3c, 0x54, 0x44, 0x76, 0x64, 0x16, 0x9b, 0x86, 0xe7,
	0x4c, 0x6a, 0x02, 0xa8, 0xe9, 0x40, 0x89, 0x32, 0xd5, 0x51, 0xa8, 0xe3, 0x77, 0x43, 0xec, 0x3b,
	0xba, 0xdd, 0xb6, 0x4c, 0x4e, 0x3e, 0x10, 0x55, 0xab, 0x26, 0x69, 0xe0, 0xf9, 0xee, 0x8e, 0x65,
	0x12, 0xfb, 0xc4, 0xe4, 0x3b, 0x17, 0x44, 0xd5, 0xaa, 0x89, 0x1e, 0x81, 0xa9, 0x9e, 0x13, 0x18,
	0x5b, 0xd8, 0xec, 0xd9, 0x7a, 0xc7, 0xc6, 0x7c, 0xb2, 0xc9, 0xca, 0xe6, 0x4f, 0x8a, 0xd1, 0x5a,
	0xdd, 0x84, 0xaa, 0xa1, 0x7b, 0xba, 0x61, 0x85, 0xbb, 0x7c, 0x41, 0x4e, 0x65, 0x9d, 0x7e, 0x6b,
	0x89, 0x03, 0x6a, 0x11, 0x8a, 0x78, 0xe9, 0x0b, 0xd2, 0xd2, 0xa3, 0x5b, 0x5c, 0xf5, 0x5a, 0xce,
	0x86, 0xcb, 0x39, 0x3d, 0x7b, 0x2f, 0xe4, 0x79, 0xd5, 0xd9, 0x70, 0x99, 0xb6, 0x26, 0x4f, 0xcd,
	0x15, 0xa8, 0x8a, 0xbe, 0x89, 0x10, 0x33, 0xbc, 0x1e, 0x97, 0x11, 0xe4, 0x91, 0x6c, 0xdf, 0x2e,
	0xee, 0xba, 0xfe, 0x2e, 0x17, 0x0a, 0xbc, 0x44, 0xb4, 0x00, 0xcd, 0xd5, 0x28, 0xd2, 0x5a, 0xfa,
	0xdc, 0xfc, 0x27, 0x05, 0xaa, 0xa2, 0x03, 0xf4, 0x28, 0x4c, 0x6f, 0x93, 0x91, 0xd8, 0x91, 0x6f,
	0xc5, 0x56, 0x60, 0x8a, 0xd5, 0x0a, 0xcf, 0xea, 0x3e, 0xa8, 0xba, 0x41, 0x5b, 0x56, 0xce, 0x15,
	0x37, 0x58, 0xa5, 0xea, 0xf9, 0x1c, 0xdc, 0x17, 0xd9, 0x40, 0x6d, 0xbf, 0xe7, 0x10, 0xd1, 0x14,
	0x21, 0x63, 0x0a, 0xef, 0x48, 0xd4, 0x40, 0x63, 0xef, 0x05, 0xda, 0xc7, 0x61, 0x86, 0x50, 0xc2,
	0xc6, 0x61, 0xca, 0xb5, 0x9b, 0xe6, 0xd5, 0xa2, 0xe1, 0x09, 0x40, 0xa4, 0xa6, 0xed, 0xf9, 0xee,
	0xbb, 0xbb, 0x51, 0x5b, 0x66, 0xd1, 0xcc, 0x92, 0x37, 0x6b, 0xe4, 0x05, 0x6f, 0xad, 0x7e, 0x50,
	0x84, 0xe2, 0x9a, 0x6b, 0xee, 0x9f, 0x8e, 0x38, 0xcb, 0xf7, 0x61, 0x1e, 0x89, 0xc5, 0x76, 0x61,
	0x3e, 0x0d, 0xb1, 0xe6, 0x9a, 0xfb, 0xbd, 0xcf, 0xbe, 0x38, 0x5c, 0x44, 0x11, 0xbf, 0xa7, 0x8b,
	0x83, 0x40, 0x5a, 0x58, 0x5e, 0x24, 0x3c, 0xe5, 0x63, 0x3d, 0x88, 0x56, 0x91, 0x97, 0x48, 0x3d,
	0x31, 0x42, 0x56, 0xd7, 0xf8, 0x5a, 0xf1, 0x12, 0xc5, 0xef, 0x9a, 0xab, 0x6b, 0x7c, 0x59, 0x58,
	0x41, 0xfd, 0xcb, 0x09, 0x98, 0x4d, 0x07, 0xb4, 0xc6, 0x5d, 0x98, 0x57, 0x13, 0xe2, 0xf0, 0x52,
	0xae, 0x20, 0x5a, 0x5f, 0x85, 0xb4, 0x48, 0xaf, 0x47, 0x8b, 0x54, 0xcc, 0x90, 0x0f, 0x32, 0x1a,
	0x73, 0x52, 0x49, 0xfc, 0x7b, 0x11, 0xe6, 0x07, 0x75, 0x8e, 0xec, 0x84, 0x1c, 0x22, 0xd6, 0xd4,
	0xda, 0xdd, 0x4f, 0x29, 0x92, 0x50, 0xcc, 0xda, 0x8a, 0xc5, 0xd4, 0xc3, 0x30, 0xa9, 0x1b, 0x06,
	0x0e, 0x82, 0x76, 0x97, 0x66, 0x9b, 0x15, 0xa8, 0x29, 0x5d, 0x67, 0x75, 0x37, 0xe9, 0xb9, 0xf2,
	0x55, 0x38, 0xd6, 0x1f, 0xb7, 0xf4, 0x31, 0x8d, 0x5c, 0xb6, 0x3d, 0xd7, 0xb6, 0x8c, 0x5d, 0xce,
	0x0b, 0x0f, 0xa6, 0x43, 0x91, 0x1a, 0x6b, 0xb5, 0x46, 0x1b, 0xa1, 0x55, 0xa8, 0x31, 0x20, 0x1f,
	0x6f, 0x70, 0xc6, 0x3f, 0x31, 0x74, 0x6a, 0x3c, 0xa5, 0x14, 0x6f, 0x60, 0x1f, 0x3b, 0x06, 0xd6,
	0xaa, 0x14, 0x5c, 0xc3, 0x1b, 0xa8, 0x3b, 0x28, 0x7b, 0x87, 0xa7, 0xbd, 0x96, 0x33, 0xa4, 0xbf,
	0xf4, 0xd1, 0x88, 0x65, 0x83, 0xf6, 0xa5, 0xea, 0xb0, 0xfa, 0xe6, 0x0b, 0x30, 0x95, 0x20, 0x60,
	0x2e, 0x0f, 0xe7, 0xcd, 0xfe, 0x13, 0xce, 0xfd, 0xdd, 0x7b, 0xea, 0x1f, 0xd5, 0xe0, 0xd0, 0xc0,
	0xf0, 0xf0, 0xb8, 0x5b, 0xea, 0xcd, 0xc4, 0x96, 0xba, 0x91, 0x3f, 0x2e, 0x3d, 0xb8, 0x56, 0xda,
	0x5c, 0x1b, 0xa9, 0xcd, 0x75, 0x6b, 0xdf, 0xfa, 0x48, 0x6e, 0xb3, 0xaf, 0x96, 0xe1, 0xbe, 0x3d,
	0xc7, 0xd2, 0xc7, 0xfd, 0x4a, 0x3f, 0xf7, 0x7f, 0xa9, 0xff, 0x4a, 0x8b, 0xbe, 0x9f, 0xf4, 0x68,
	0xc9, 0xa9, 0xc8, 0x96, 0x8f, 0x69, 0x7e, 0x8a, 0x74, 0x0d, 0x86, 0x58, 0x3a, 0x9c, 0xbf, 0xa5,
	0x74, 0x79, 0x60, 0x55, 0xc4, 0x04, 0x6d, 0xfe, 0x4e, 0x11, 0xe6, 0x07, 0x21, 0x41, 0x5f, 0x51,
	0x60, 0xc2, 0xb6, 0xba, 0x56, 0x28, 0x02, 0x22, 0xdd, 0x7b, 0x3e, 0xf0, 0xd6, 0x0d, 0xda, 0x9f,
	0x08, 0x7d, 0xd2, 0x02, 0xfa, 0x50, 0x81, 0xaa, 0xcf, 0x12, 0xad, 0x45, 0x40, 0xc5, 0xbd, 0xf7,
	0x23, 0xe1, 0xa9, 0xdd, 0x7c, 0x2c, 0xd1, 0x00, 0x68, 0xc8, 0x34, 0x1e, 0x64, 0xae, 0x9d, 0xfc,
	0x02, 0x4c, 0x25, 0xb0, 0xe6, 0x02, 0xfe, 0x5a, 0x01, 0xee, 0x1f, 0xc2, 0xb1, 0x7b, 0x08, 0x83,
	0x0c, 0xf2, 0xf9, 0x5d, 0x49, 0x61, 0xb0, 0xd0, 0xd2, 0xeb, 0xfb, 0xbb, 0x99, 0xf6, 0x52, 0x1e,
	0x77, 0x25, 0x16, 0xd5, 0x1f, 0x28, 0x30, 0x93, 0x12, 0xf0, 0xc4, 0x30, 0xdd, 0xb6, 0x1c, 0x61,
	0xef, 0xd3, 0xe7, 0x31, 0x6e, 0x91, 0xcc, 0x42, 0xb1, 0x67, 0x99, 0xdc, 0x0e, 0x21, 0x8f, 0x64,
	0x0f, 0x2d, 0xae, 0xad, 0xa6, 0x2c, 0x44, 0x58, 0x5c, 0x5b, 0x15, 0x96, 0xe4, 0xa0, 0xe3, 0x84,
	0x89, 0x81, 0xc7, 0x09, 0xea, 0x07, 0x15, 0xa8, 0xf0, 0x58, 0xec, 0xfe, 0x99, 0x92, 0x2f, 0x25,
	0x4c, 0xc9, 0x27, 0xb3, 0x04, 0x82, 0x65, 0xaf, 0x6e, 0x29, 0x65, 0x4f, 0x3e, 0x95, 0x0d, 0x41,
	0x52, 0x54, 0xfe, 0xa4, 0xc8, 0x9d, 0xaf, 0x41, 0x59, 0x0f, 0xcb, 0xc4, 0x8c, 0xf3, 0xc3, 0x6c,
	0x01, 0x51, 0x79, 0x84, 0xad, 0x35, 0xd7, 0x0f, 0x35, 0x06, 0x8c, 0x5e, 0x85, 0x5a, 0x3a, 0x0c,
	0x7a, 0x36, 0x3b, 0xa6, 0x54, 0x1c, 0x34, 0x46, 0x45, 0x78, 0x44, 0x84, 0xa6, 0x85, 0xfd, 0x19,
	0x57, 0xa0, 0x63, 0xb1, 0x33, 0xb9, 0xba, 0x16, 0xd0, 0xfb, 0x40, 0x35, 0x4d, 0xae, 0x42, 0x8f,
	0xc1, 0xb4, 0xed, 0xea, 0x66, 0x47, 0xb7, 0x75, 0xc7, 0xa0, 0x48, 0xd8, 0xe2, 0xa7, 0x6a, 0x9b,
	0x2f, 0xc2, 0xf4, 0x5d, 0x84, 0x3a, 0x7f, 0x41, 0x81, 0x12, 0xa1, 0xc6, 0xc0, 0xa8, 0x5e, 0x13,
	0xaa, 0xf4, 0x32, 0xab, 0xe1, 0xda, 0x22, 0xa8, 0x27, 0xca, 0xcc, 0x5f, 0xf3, 0x43, 0x1e, 0xba,
	0xa1, 0xcf, 0x84, 0xa5, 0x43, 0xdd, 0xdf, 0xc4, 0x61, 0x9b, 0xbe, 0x62, 0x93, 0x06, 0x56, 0x45,
	0x3b, 0x11, 0x51, 0x5e, 0xfa, 0x9a, 0x85, 0x6f, 0xa8, 0xdf, 0x48, 0x5e, 0x36, 0xff, 0x3c, 0x8e,
	0x30, 0xed, 0xc0, 0x61, 0x79, 0x96, 0x6d, 0xcb, 0xd9, 0xf4, 0x31, 0xcd, 0xf5, 0x66, 0x4a, 0xe3,
	0x42, 0x0e, 0x5e, 0x6a, 0xdd, 0x70, 0x75, 0xf3, 0x92, 0xa0, 0x17, 0x43, 0xa4, 0x1d, 0x4a, 0x10,
	0x51, 0x60, 0x6f, 0x5e, 0x82, 0xb9, 0x01, 0xad, 0xa3, 0xe8, 0xa6, 0x44, 0x20, 0x1a, 0xdd, 0xa4,
	0xc1, 0xe9, 0x69, 0x28, 0xac, 0xae, 0x71, 0xf2, 0x14, 0x56, 0xd7, 0xd4, 0x1f, 0x91, 0x69, 0xb0,
	0xd4, 0x83, 0x31, 0xb7, 0xe2, 0x62, 0x22, 0x6e, 0x79, 0x32, 0x43, 0xba, 0x43, 0x3a, 0x68, 0x19,
	0x6d, 0x97, 0x62, 0xbc, 0x5d, 0xc6, 0x0f, 0x64, 0x7e, 0xb5, 0x0c, 0x87, 0x06, 0xe6, 0x41, 0xec,
	0x9f, 0xac, 0xb9, 0x9e, 0x90, 0x35, 0x67, 0xf2, 0xa7, 0x64, 0xc8, 0x92, 0xe7, 0x95, 0x94, 0xe4,
	0x79, 0x7e, 0x1c, 0x74, 0xa9, 0xe8, 0x67, 0x81, 0xcb, 0xa1, 0x27, 0x61, 0xd6, 0xc4, 0x81, 0xe5,
	0x63, 0xb3, 0xcd, 0x33, 0x40, 0x02, 0x1e, 0x5e, 0x9c, 0xe1, 0xf5, 0x1c, 0x5f, 0x80, 0x4c, 0x59,
	0xb0, 0xb0, 0xb5, 0xbc, 0x32, 0xe6, 0xc4, 0x86, 0x88, 0x99, 0xab, 0x30, 0xe9, 0xb9, 0x66, 0x7b,
	0xac, 0x50, 0x65, 0xdd, 0x73, 0xcd, 0xdb, 0x1c, 0xf0, 0x2e, 0xe5, 0x88, 0x19, 0xed, 0xdd, 0x27,
	0x61, 0xd6, 0xe8, 0xf9, 0x3e, 0xf1, 0x81, 0xd2, 0x14, 0xe2, 0xf5, 0x11, 0x85, 0x16, 0x60, 0xce,
	0xed, 0x04, 0xd8, 0xdf, 0xc1, 0x66, 0x5b, 0x3a, 0xef, 0x66, 0x81, 0x21, 0x24, 0x5e, 0x5d, 0x8d,
	0xde, 0xa8, 0xbf, 0x58, 0x02, 0x88, 0x33, 0x8d, 0xf6, 0x8f, 0xfd, 0x2e, 0x26, 0xd8, 0xef, 0x44,
	0xc6, 0x4c, 0x27, 0x99, 0xe7, 0xae, 0xa4, 0x78, 0xae, 0x95, 0x19, 0x47, 0x92, 0xd1, 0xfe, 0x4c,
	0xc9, 0xcf, 0x68, 0x57, 0xa0, 0x1a, 0x5d, 0xc0, 0x67, 0xde, 0xc0, 0xf1, 0xe1, 0xb7, 0xfb, 0xe5,
	0xdb, 0xf9, 0x5a, 0x04, 0xbb, 0x7f, 0xac, 0xf4, 0xf1, 0x30, 0xc3, 0xef, 0x95, 0x88, 0x40, 0x13,
	0xa9, 0x83, 0xfb, 0xc6, 0x0b, 0x17, 0x12, 0xbc, 0xf0, 0x54, 0xb6, 0x34, 0x46, 0x99, 0x15, 0x2e,
	0xa7, 0x58, 0xe1, 0x64, 0x56, 0x14, 0x49, 0x4e, 0xf8, 0x0d, 0xc1, 0x09, 0xf2, 0xf2, 0x2a, 0xfb,
	0xb8, 0xbc, 0x85, 0x71, 0x97, 0xf7, 0x7b, 0xb1, 0xa2, 0x3e, 0x0b, 0x0d, 0xb1, 0xbe, 0x4e, 0xaf,
	0xdb, 0xc1, 0x7e, 0x9b, 0x47, 0xb2, 0xb1, 0xc9, 0xd7, 0xf9, 0x30, 0x7f, 0x7f, 0x8b, 0xbe, 0x5e,
	0x17, 0x6f, 0xc9, 0x72, 0x73, 0x88, 0xae, 0x15, 0xc4, 0x40, 0xec, 0x20, 0x06, 0xb1, 0x57, 0x37,
	0xa5, 0x37, 0xa4, 0x2b, 0xb1, 0x21, 0xfa, 0xba, 0x62, 0x46, 0xc8, 0x61, 0xfe, 0x3e, 0xd5, 0x95,
	0xfa, 0x41, 0x19, 0x20, 0xce, 0x13, 0xfd, 0xbf, 0x91, 0x1a, 0x71, 0xff, 0xe3, 0x4b, 0x0d, 0x19,
	0xc7, 0xcf, 0xa0, 0xd4, 0xf8, 0x97, 0x98, 0xad, 0xf6, 0x90, 0x05, 0xca, 0x5e, 0xb2, 0x80, 0x58,
	0xaa, 0xd1, 0x7c, 0x19, 0x0b, 0x45, 0x65, 0x42, 0x13, 0x76, 0x57, 0x5e, 0xa2, 0x09, 0x63, 0x98,
	0x19, 0x5e, 0x1f, 0xd1, 0xe4, 0x24, 0x20, 0x7d, 0x47, 0xb7, 0xe8, 0x39, 0x4c, 0xdc, 0x98, 0x1d,
	0x41, 0x1e, 0x8c, 0xde, 0x44, 0xcd, 0x4f, 0xc1, 0x7c, 0xcf, 0x19, 0x00, 0xc0, 0x2c, 0xdb, 0x39,
	0xe9, 0x9d, 0x00, 0x51, 0xbf, 0x5f, 0x82, 0xba, 0x94, 0xaf, 0xbb, 0x7f, 0xcc, 0xb8, 0x98, 0x60,
	0xc6, 0x93, 0x59, 0x13, 0x86, 0x65, 0x6e, 0xbc, 0x9a, 0xe2, 0xc6, 0x85, 0xec, 0x48, 0x92, 0xec,
	0xf8, 0x6f, 0x3f, 0x03, 0xec, 0x88, 0x1e, 0x86, 0x49, 0x91, 0xc3, 0x22, 0xe5, 0xae, 0xd4, 0x79,
	0x1d, 0x8d, 0x72, 0x7d, 0x3c, 0x7a, 0xee, 0xe7, 0x0b, 0x30, 0x29, 0xa7, 0x08, 0x8f, 0xcb, 0x33,
	0xc7, 0xf8, 0xf1, 0x64, 0x60, 0xb9, 0x0e, 0xf6, 0x39, 0xef, 0xc8, 0x55, 0xe8, 0xd3, 0x00, 0x9e,
	0xee, 0xeb, 0x5d, 0x1c, 0xe2, 0xc8, 0x17, 0x7e, 0x3e, 0x73, 0xea, 0x72, 0x6b, 0x2d, 0x82, 0x65,
	0x56, 0xaa, 0x84, 0xac, 0xf9, 0x12, 0xcc, 0xa4, 0x5e, 0xe7, 0x72, 0x41, 0xfe, 0x50, 0x81, 0xa9,
	0xc4, 0x8a, 0xa3, 0x37, 0x60, 0xb2, 0xab, 0x87, 0xc6, 0x56, 0x9b, 0x27, 0x42, 0x32, 0xc7, 0xf0,
	0x85, 0xec, 0x3c, 0xd3, 0xba, 0x49, 0xc0, 0xe5, 0xb4, 0xc8, 0x7a, 0x37, 0xae, 0x69, 0x9e, 0x87,
	0xd9, 0x74, 0x83, 0x5c, 0x23, 0xfe, 0x6e, 0x01, 0xca, 0x34, 0x71, 0x75, 0xdc, 0xe5, 0x8a, 0x03,
	0xeb, 0x85, 0xc4, 0xa1, 0x96, 0x14, 0x8a, 0x2f, 0x26, 0x43, 0xf1, 0x17, 0xa3, 0xaf, 0x6c, 0x64,
	0x39, 0x2a, 0xa7, 0x83, 0xe3, 0x67, 0x0c, 0xe2, 0x33, 0x1b, 0x8f, 0xc3, 0xcc, 0x86, 0xe5, 0x07,
	0x2c, 0xb3, 0x23, 0x08, 0xf5, 0xae, 0xc7, 0x73, 0x53, 0xa7, 0x69, 0xf5, 0x6d, 0x51, 0xcb, 0xbe,
	0xfc, 0x94, 0x68, 0xc7, 0x92, 0x54, 0xa7, 0x48, 0x6d, 0xdc, 0x6c, 0x1e, 0xca, 0x34, 0xc5, 0x8b,
	0xa6, 0xf2, 0x95, 0x35, 0x56, 0x88, 0x9c, 0xd3, 0x6a, 0xec, 0x9c, 0xaa, 0x8b, 0x50, 0x97, 0x06,
	0x84, 0x1e, 0x02, 0x30, 0xdc, 0xae, 0xe7, 0x3a, 0xd8, 0xc1, 0x22, 0x5f, 0x48, 0xaa, 0x21, 0x28,
	0x88, 0x03, 0x2e, 0x72, 0x86, 0xc8, 0xb3, 0xfa, 0x1f, 0x0a, 0x54, 0xc4, 0x07, 0xaf, 0xae, 0x43,
	0xcd, 0xf0, 0x7a, 0xed, 0x1e, 0x25, 0x93, 0x92, 0x21, 0x3c, 0xc4, 0x01, 0xa9, 0x23, 0xbd, 0xe6,
	0x5a, 0x4e, 0xa8, 0x55, 0x0d, 0xaf, 0x77, 0x87, 0xd2, 0xf5, 0x15, 0x98, 0x64, 0x87, 0xd4, 0x1c,
	0x5f, 0x61, 0x2c, 0x7c, 0x75, 0x86, 0x83, 0xa2, 0x6c, 0x5e, 0x60, 0xbe, 0x38, 0x7d, 0x83, 0x1e,
	0x80, 0x5a, 0x4c, 0x47, 0x9e, 0x4e, 0x13, 0xca, 0x34, 0x8c, 0x59, 0xac, 0xc8, 0x59, 0x4c, 0xfd,
	0x48, 0x81, 0xa3, 0x7d, 0xd7, 0xd7, 0xf0, 0xa6, 0x45, 0x53, 0xbf, 0xb3, 0x7c, 0x40, 0x24, 0xfd,
	0xc5, 0x2d, 0x42, 0x72, 0xcb, 0xc4, 0x4e, 0x68, 0x6d, 0x58, 0x3c, 0x0d, 0xa3, 0xa6, 0x49, 0x35,
	0x84, 0x1f, 0x3d, 0xbb, 0xb7, 0x69, 0x89, 0x83, 0x6f, 0x5e, 0x42, 0x47, 0xa0, 0x12, 0x58, 0x9f,
	0xc7, 0xed, 0xcd, 0x0e, 0xe7, 0x95, 0x09, 0x52, 0xbc, 0xda, 0x21, 0x3a, 0x19, 0x3b, 0xa6, 0x47,
	0xa6, 0xc8, 0x43, 0x57, 0x51, 0x59, 0x7d, 0x05, 0x1e, 0x4e, 0x8f, 0xfe, 0x8e, 0x73, 0x57, 0xe3,
	0x57, 0x3f, 0x54, 0xe0, 0x91, 0xc1, 0x37, 0xee, 0xee, 0x8a, 0x2c, 0xd2, 0xf4, 0x8a, 0x89, 0xe9,
	0x25, 0x62, 0xc0, 0xa5, 0x54, 0x0c, 0x58, 0x0d, 0xe1, 0xb1, 0x81, 0x83, 0xb9, 0xcb, 0x59, 0x0e,
	0x4f, 0xe7, 0x55, 0xff, 0xae, 0x0c, 0x65, 0x7a, 0x6f, 0x62, 0x5c, 0xa1, 0x73, 0x31, 0x71, 0xc8,
	0x76, 0x62, 0xf4, 0x05, 0x0d, 0xf6, 0x2b, 0x19, 0x11, 0x87, 0x13, 0x87, 0x68, 0xb5, 0xc8, 0x26,
	0xf8, 0xa8, 0x04, 0xb5, 0xa8, 0x2d, 0xfa, 0x6c, 0x94, 0xaa, 0x4b, 0x75, 0x04, 0x1f, 0xe6, 0xd9,
	0x3c, 0xfd, 0xf1, 0xd4, 0x5d, 0xaa, 0x55, 0x44, 0xea, 0x2e, 0x2d, 0xa0, 0x4f, 0xc0, 0x94, 0xb1,
	0x85, 0x8d, 0xed, 0x36, 0x4f, 0xbe, 0xe4, 0x04, 0x9c, 0xa4, 0x95, 0x4b, 0xac, 0x0e, 0x19, 0x30,
	0xe3, 0xb8, 0x8c, 0xb5, 0xd9, 0x18, 0x84, 0xc2, 0x3b, 0x97, 0x6b, 0x10, 0xb7, 0x38, 0x0e, 0x36,
	0x8c, 0x69, 0x47, 0x2e, 0x06, 0xe8, 0x1a, 0x94, 0x76, 0x74, 0x5f, 0xe4, 0x7a, 0x3e, 0x97, 0x0b,
	0xf3, 0xab, 0xba, 0xd0, 0xa3, 0x14, 0x47, 0xf3, 0x0c, 0xd4, 0xa2, 0xaa, 0x5c, 0xa1, 0x19, 0x4b,
	0xa4, 0xa9, 0x33, 0xea, 0x9c, 0x00, 0xc4, 0xa8, 0x63, 0x39, 0x21, 0xf6, 0x77, 0x74, 0x9a, 0x50,
	0xcb, 0xc5, 0xce, 0x2c, 0x7d, 0xb3, 0xca, 0x5f, 0xac, 0x63, 0x83, 0xb4, 0xa6, 0xf7, 0x6f, 0x92,
	0xad, 0x99, 0x28, 0x9a, 0xa5, 0x6f, 0xa4, 0xd6, 0xcd, 0x4f, 0xc1, 0x54, 0x82, 0x20, 0x64, 0x54,
	0x2c, 0x17, 0x9b, 0x1f, 0x20, 0xd1, 0x02, 0xba, 0x0f, 0xaa, 0xbd, 0x00, 0xfb, 0xed, 0x5e, 0x94,
	0x25, 0x55, 0x21, 0xe5, 0x3b, 0x96, 0xc9, 0xd2, 0x83, 0xc2, 0x2d, 0xd7, 0x14, 0xec, 0xc3, 0x4a,
	0xea, 0x0e, 0x94, 0xe8, 0xf5, 0x9b, 0x31, 0xf9, 0xfa, 0x0c, 0x94, 0xfd, 0x9e, 0x8d, 0x45, 0x1c,
	0x6e, 0xc4, 0xf5, 0xa1, 0x9e, 0x8d, 0x35, 0xd6, 0x5e, 0xfd, 0x91, 0x02, 0x75, 0xf9, 0x2a, 0xcd,
	0xd8, 0xfb, 0xaa, 0x1a, 0xf4, 0xe8, 0xc1, 0x92, 0x18, 0xc2, 0x88, 0xc4, 0x7a, 0xd6, 0x58, 0x8b,
	0xa0, 0xd0, 0x55, 0xa8, 0xd2, 0x0b, 0x42, 0x3e, 0xde, 0xc8, 0xe4, 0x70, 0xa6, 0xf3, 0x14, 0x2a,
	0x04, 0x5a, 0xc3, 0x1b, 0xea, 0xfb, 0x50, 0x97, 0x2e, 0x0e, 0x7d, 0xec, 0x04, 0xfd, 0x5b, 0x05,
	0x50, 0xff, 0xc5, 0xa5, 0x9f, 0x01, 0xba, 0x7e, 0x57, 0x81, 0x12, 0x99, 0x28, 0xdd, 0x89, 0xd8,
	0xef, 0x88, 0x93, 0x7b, 0x56, 0x40, 0x0f, 0x02, 0xe8, 0x9e, 0xd5, 0xde, 0xf4, 0xdd, 0x9e, 0x27,
	0x8e, 0x4c, 0x6b, 0xba, 0x67, 0x5d, 0xa5, 0x15, 0x44, 0xae, 0xc7, 0x47, 0xfa, 0x2c, 0x77, 0x5c,
	0x3a, 0x6f, 0x7f, 0x14, 0xa6, 0xa3, 0xa3, 0x40, 0x2a, 0xed, 0xa9, 0x44, 0xa9, 0x69, 0x53, 0xa2,
	0x96, 0xe6, 0x7d, 0xa2, 0xe3, 0x70, 0xd0, 0x71, 0x9d, 0x76, 0xd4, 0xb4, 0xe7, 0xdb, 0xe2, 0x68,
	0x69, 0xc6, 0x71, 0x1d, 0x71, 0x24, 0x7d, 0xc7, 0xb7, 0x03, 0xd5, 0x83, 0x0a, 0x27, 0xc6, 0xc0,
	0x13, 0xce, 0xa3, 0x50, 0x27, 0xc3, 0x15, 0xe7, 0x8e, 0x3c, 0x97, 0x51, 0xf7, 0x2c, 0x71, 0x3a,
	0x39, 0xe8, 0x90, 0x73, 0xb8, 0x4a, 0xfc, 0x7e, 0x09, 0x2a, 0xfc, 0x2e, 0xd8, 0xb8, 0xcb, 0x7d,
	0x41, 0x64, 0x40, 0x67, 0xf9, 0xec, 0x24, 0xef, 0xab, 0x25, 0xa7, 0x41, 0x2f, 0xa5, 0x52, 0x3c,
	0x9e, 0xca, 0x86, 0x21, 0x75, 0x28, 0x29, 0xdc, 0xdb, 0x26, 0x54, 0x45, 0x0c, 0x4a, 0x1c, 0x0b,
	0x89, 0x32, 0x3a, 0x07, 0xf7, 0xd1, 0x94, 0x68, 0xcb, 0xd9, 0x6c, 0x9b, 0x58, 0x37, 0x6d, 0xcb,
	0xc1, 0x44, 0x76, 0xba, 0x8e, 0x19, 0x70, 0xf9, 0x79, 0x44, 0x34, 0x58, 0xe6, 0xef, 0xd7, 0xd9,
	0x6b, 0x74, 0x12, 0x90, 0xe1, 0x3a, 0xcc, 0x71, 0x34, 0x76, 0x93, 0xf9, 0x4c, 0x07, 0xa5, 0x37,
	0x3c, 0x87, 0xa9, 0x01, 0x95, 0xa0, 0x17, 0x78, 0xd8, 0x31, 0xf9, 0xe7, 0x5f, 0x45, 0x31, 0x91,
	0xc3, 0x5c, 0xce, 0x91, 0x34, 0x1e, 0x41, 0x35, 0xbf, 0x10, 0xb9, 0xb8, 0xcb, 0x51, 0xb6, 0x36,
	0xb3, 0xa7, 0xf3, 0x6d, 0x13, 0x91, 0xdb, 0x7d, 0x02, 0x10, 0x75, 0x1c, 0x04, 0x9d, 0xe4, 0xfc,
	0xf0, 0x59, 0xf2, 0x46, 0x84, 0xed, 0x88, 0x13, 0xa1, 0xfe, 0x43, 0x05, 0xea, 0xd2, 0x4d, 0xc4,
	0xbb, 0x38, 0x50, 0x93, 0xac, 0x9a, 0x93, 0x59, 0x2f, 0x3e, 0x0e, 0x8e, 0x8d, 0x14, 0xb3, 0xdc,
	0xcc, 0x94, 0x91, 0x24, 0x99, 0xe7, 0xc7, 0xe2, 0x24, 0xa9, 0x01, 0x15, 0xd3, 0xed, 0xea, 0x96,
	0x23, 0x04, 0x85, 0x28, 0xf2, 0x63, 0x57, 0x9a, 0x34, 0x2c, 0x1d, 0xbb, 0xd2, 0x32, 0x11, 0x2e,
	0xb8, 0xab, 0x5b, 0x36, 0xe7, 0x06, 0x56, 0x40, 0x01, 0x1c, 0x5d, 0xb9, 0x7d, 0x7b, 0xad, 0x1d,
	0xa7, 0x1f, 0xb3, 0x93, 0x4b, 0x22, 0xd5, 0xd8, 0x02, 0x8c, 0x95, 0xdb, 0xf6, 0x00, 0x41, 0xba,
	0x26, 0xf2, 0x97, 0xf9, 0xd1, 0x69, 0x94, 0x18, 0x71, 0x19, 0x8e, 0x46, 0xfd, 0x19, 0x3e, 0xa6,
	0x9e, 0x82, 0x2e, 0xae, 0xe7, 0xc8, 0x17, 0x79, 0x1e, 0x10, 0xcd, 0x96, 0xa2, 0x56, 0xec, 0xd8,
	0x92, 0x9e, 0x9f, 0x9e, 0x82, 0x43, 0x8b, 0x4b, 0x37, 0x2f, 0xb7, 0xa9, 0x45, 0x20, 0x03, 0x33,
	0x9f, 0x01, 0x91, 0x97, 0x77, 0x02, 0xec, 0x4b, 0x20, 0x8f, 0xc2, 0x34, 0x05, 0xa1, 0xa1, 0x12,
	0xff, 0x8e, 0x76, 0x43, 0x7c, 0x77, 0x98, 0xd4, 0xae, 0x8b, 0xca, 0xe6, 0xb7, 0xe2, 0x44, 0xea,
	0x53, 0x30, 0x2f, 0x5d, 0x61, 0x6d, 0xbb, 0x1d, 0x9a, 0xe4, 0xcb, 0x44, 0x5e, 0x55, 0x9b, 0x93,
	0xde, 0xbd, 0xcc, 0x5f, 0x0d, 0x49, 0x79, 0x4b, 0xde, 0x52, 0x2b, 0xa6, 0x6f, 0xa9, 0xed, 0x39,
	0xa1, 0xd2, 0x9e, 0x13, 0x7a, 0x13, 0x2a, 0x26, 0x0e, 0x75, 0xcb, 0x16, 0xa9, 0xb3, 0x57, 0x72,
	0xb2, 0x57, 0x8b, 0x20, 0x95, 0xaa, 0x97, 0x19, 0x36, 0x4d, 0xa0, 0x6d, 0x7e, 0x43, 0x81, 0xc3,
	0x83, 0xdb, 0x10, 0x93, 0x8b, 0x71, 0x9e, 0xb8, 0x97, 0xc3, 0x4a, 0xd4, 0x31, 0xc1, 0x7e, 0x48,
	0xc8, 0xcb, 0x09, 0xc0, 0x8b, 0x84, 0xfe, 0xe4, 0xb1, 0x1d, 0x84, 0x7a, 0xc7, 0xc6, 0xa4, 0x01,
	0xe3, 0xc6, 0x29, 0x52, 0xbb, 0x2e, 0x2a, 0xa9, 0x0e, 0xe1, 0xb7, 0xbf, 0x44, 0x76, 0x25, 0xd1,
	0x21, 0xac, 0x8a, 0xa8, 0xcc, 0xdf, 0x82, 0x01, 0x69, 0x88, 0x2c, 0x00, 0xb0, 0x05, 0x07, 0x37,
	0x0d, 0x1c, 0xbf, 0x5c, 0xb6, 0x82, 0x6d, 0xbe, 0xed, 0x87, 0x1b, 0xe8, 0x57, 0x97, 0x2e, 0x27,
	0xa1, 0x12, 0xc9, 0x94, 0xfd, 0x48, 0xd1, 0xdb, 0x30, 0xaf, 0xbf, 0x13, 0x5c, 0x26, 0xb2, 0xc7,
	0x32, 0x2e, 0xd9, 0xae, 0xb1, 0xbd, 0x1e, 0xba, 0xbe, 0x50, 0x31, 0xc3, 0xbf, 0x99, 0xbb, 0xf8,
	0xda, 0x7a, 0x1f, 0x60, 0xa2, 0xbf, 0x81, 0xa8, 0xd1, 0x4d, 0x88, 0x2e, 0x47, 0x65, 0x4a, 0xb8,
	0x5f, 0xe1, 0x8d, 0x13, 0xa8, 0x23, 0x14, 0x68, 0x0d, 0x6a, 0x9b, 0xcc, 0xa2, 0xda, 0x10, 0xa1,
	0xdb, 0xe1, 0x97, 0x78, 0xaf, 0x8a, 0xd6, 0x09, 0x84, 0x31, 0x12, 0x74, 0x1e, 0x8a, 0xce, 0x86,
	0xe0, 0xc5, 0xe1, 0x32, 0xe3, 0xd6, 0x95, 0xf5, 0x04, 0x16, 0x02, 0x48, 0xe0, 0xfd, 0x8e, 0xc9,
	0x3f, 0xbe, 0x31, 0xe2, 0x38, 0xf5, 0xd2, 0x72, 0x12, 0xde, 0xef, 0x98, 0x68, 0x19, 0xca, 0x56,
	0x60, 0x04, 0x16, 0xff, 0x04, 0xc7, 0xf0, 0x50, 0xcb, 0xea, 0xfa, 0xd2, 0xfa, 0x6a, 0x02, 0x07,
	0x03, 0x26, 0x32, 0xdb, 0xb0, 0x1c, 0x22, 0x45, 0xab, 0x59, 0x64, 0x36, 0x6d, 0x9a, 0xc0, 0xc3,
	0xc1, 0x29, 0x22, 0xec, 0x6d, 0x6d, 0x88, 0x6f, 0x54, 0x8e, 0x12, 0xfe, 0xde, 0x56, 0x8a, 0x28,
	0x1c, 0x1c, 0xbd, 0x00, 0x85, 0x0d, 0x83, 0x7f, 0x8d, 0x63, 0xb8, 0xe9, 0x71, 0x65, 0x29, 0x81,
	0xa0, 0xb0, 0x61, 0xa0, 0x6b, 0x50, 0xd9, 0x20, 0x3c, 0x84, 0x7d, 0xfe, 0x45, 0x8e, 0xe1, 0x37,
	0xda, 0xae, 0xb0, 0xb6, 0x09, 0x34, 0x02, 0x01, 0xba, 0x09, 0xb0, 0x61, 0xe3, 0x77, 0xd9, 0x4b,
	0xfe, 0x61, 0x8e, 0x93, 0x23, 0xd0, 0x89, 0xe6, 0x1c, 0x97, 0x84, 0x80, 0x70, 0xa0, 0xfe, 0xf9,
	0x9e, 0x8f, 0xaf, 0x58, 0x36, 0xe6, 0x5f, 0xe9, 0x18, 0xce, 0x81, 0x8b, 0xa2, 0x75, 0x92, 0x03,
	0x23, 0x24, 0x48, 0x87, 0xa9, 0x9d, 0xc0, 0xdb, 0xc2, 0x62, 0x3f, 0xf1, 0x8f, 0x75, 0x0c, 0x8f,
	0xef, 0xbe, 0xca, 0x21, 0x2c, 0x3f, 0xec, 0xe9, 0x76, 0xdf, 0xe6, 0x4f, 0x62, 0x24, 0xf4, 0x7c,
	0xbb, 0xe7, 0x76, 0x76, 0x43, 0xcc, 0xbf, 0xd2, 0x31, 0x9c, 0x9e, 0xaf, 0xb0, 0xb6, 0x49, 0x7a,
	0x72, 0x04, 0x11, 0x01, 0xa8, 0x98, 0x9a, 0xcd, 0x4a, 0x80, 0xbe, 0x11, 0xc6, 0x48, 0xd4, 0x5f,
	0x51, 0xe0, 0xd8, 0x28, 0xf1, 0x42, 0x2c, 0x05, 0x96, 0x74, 0xbb, 0xba, 0x2c, 0x0c, 0x50, 0x51,
	0xa6, 0xf7, 0xe4, 0x82, 0xdb, 0xf1, 0x75, 0x70, 0x5e, 0x22, 0x46, 0xba, 0x47, 0xcc, 0xce, 0x50,
	0xdc, 0x7a, 0x29, 0x6b, 0x71, 0x05, 0x3b, 0x48, 0x63, 0x37, 0x42, 0xb9, 0x31, 0x19, 0x95, 0xd5,
	0xe3, 0x30, 0x3f, 0x48, 0x12, 0xd1, 0x54, 0x30, 0x22, 0xca, 0xb8, 0xff, 0x40, 0x9e, 0xd5, 0x4f,
	0xc3, 0x4c, 0x4a, 0x32, 0xd0, 0xc8, 0x10, 0xd5, 0xcd, 0x42, 0xcf, 0xb0, 0x52, 0x04, 0x5e, 0x88,
	0xc1, 0x13, 0xc3, 0x28, 0xa6, 0x86, 0xb1, 0x03, 0xd3, 0xc9, 0xdd, 0x81, 0x1e, 0x02, 0x9e, 0x64,
	0xf6, 0xda, 0x6b, 0xb7, 0x84, 0x35, 0x25, 0xd5, 0xa0, 0x59, 0x28, 0xda, 0x3d, 0x87, 0x1f, 0x0c,
	0x92, 0x47, 0x89, 0x38, 0xc5, 0x04, 0x71, 0x86, 0x4d, 0xff, 0xa3, 0x02, 0xcc, 0xa6, 0x77, 0x01,
	0x55, 0x9e, 0xbe, 0x25, 0x4d, 0x8a, 0x95, 0xf6, 0xa4, 0xfe, 0x35, 0xa8, 0x31, 0x93, 0x40, 0x1b,
	0xd3, 0xdf, 0x8c, 0xc1, 0x87, 0x0d, 0x16, 0xdd, 0x86, 0x8a, 0xeb, 0xb1, 0xbb, 0x8d, 0x59, 0xbe,
	0x35, 0x9e, 0x9e, 0x57, 0xeb, 0x65, 0x4f, 0xfa, 0xbc, 0x83, 0x40, 0xd5, 0x3c, 0x07, 0x93, 0xf2,
	0x8b, 0x5c, 0x07, 0x22, 0x67, 0x60, 0x6e, 0x80, 0x48, 0x42, 0xc7, 0xa0, 0x6e, 0xea, 0xa1, 0x1e,
	0x30, 0x4b, 0x88, 0xa3, 0x92, 0xab, 0xd4, 0x0f, 0x14, 0x78, 0x70, 0xa8, 0x56, 0xa7, 0xa1, 0x69,
	0x53, 0x02, 0xe7, 0xa5, 0x7b, 0xb0, 0x05, 0x5c, 0x98, 0xbb, 0x6a, 0x85, 0x1a, 0xf6, 0xdc, 0x34,
	0x03, 0xfa, 0xd8, 0x73, 0x03, 0x2b, 0x74, 0x7d, 0x41, 0x0e, 0xa9, 0x86, 0xa1, 0x64, 0xc7, 0x6c,
	0xc2, 0xa2, 0x17, 0x65, 0x32, 0x18, 0xd3, 0xf2, 0xe9, 0x91, 0x94, 0xf0, 0xf1, 0xe2, 0x0a, 0x15,
	0xc3, 0xa1, 0x81, 0xda, 0x9a, 0x80, 0x89, 0x68, 0x7a, 0xc0, 0x7b, 0x8c, 0x2b, 0x72, 0xef, 0xa9,
	0xaf, 0x14, 0x60, 0x26, 0xa5, 0x89, 0x49, 0xfb, 0xae, 0xeb, 0x58, 0x34, 0x7d, 0x8d, 0xed, 0xa9,
	0xa8, 0xbc, 0xc7, 0xfd, 0xf7, 0xbd, 0x76, 0x15, 0xcd, 0x15, 0x75, 0x6d, 0xf1, 0x95, 0x09, 0xf2,
	0x4c, 0xea, 0x88, 0x81, 0xcc, 0x5d, 0x04, 0xfa, 0x4c, 0x2c, 0xce, 0x6d, 0xbc, 0xeb, 0x5b, 0xce,
	0x26, 0x37, 0xfe, 0x45, 0x31, 0xb9, 0x6d, 0x2a, 0xfb, 0xb7, 0x6d, 0xaa, 0x29, 0x3a, 0xfc, 0xa9,
	0x02, 0x07, 0xfb, 0xec, 0x09, 0xa4, 0xc2, 0x64, 0x9c, 0xc4, 0xaa, 0xdb, 0x9c, 0xdc, 0x89, 0x3a,
	0xb2, 0x15, 0xac, 0xb7, 0xc5, 0xea, 0x92, 0x47, 0x21, 0x75, 0x8a, 0xb1, 0xd4, 0x79, 0x0c, 0xa6,
	0xa9, 0x65, 0x42, 0x43, 0xa6, 0x1b, 0x71, 0x90, 0x24, 0x55, 0x2b, 0xd1, 0xb1, 0xbc, 0xa7, 0x74,
	0x9a, 0x48, 0x8d, 0xfc, 0x6d, 0x38, 0x34, 0x50, 0xa9, 0x12, 0xde, 0x0c, 0x22, 0x4f, 0x43, 0xf0,
	0x66, 0x5c, 0x43, 0x6f, 0x5b, 0x6f, 0xe9, 0x3e, 0x0d, 0x21, 0x89, 0x5c, 0xf6, 0xa8, 0x62, 0x28,
	0xd3, 0x7c, 0x0a, 0x1e, 0x1a, 0xae, 0x71, 0x49, 0xdf, 0x4c, 0x1f, 0xad, 0xc5, 0xfa, 0x41, 0xaa,
	0xd9, 0x6b, 0x83, 0xaa, 0x5f, 0x57, 0x60, 0x6e, 0x80, 0xbe, 0x65, 0xa3, 0xd9, 0xb4, 0x82, 0x30,
	0xda, 0x65, 0x51, 0x99, 0xe0, 0xe2, 0x5f, 0xc7, 0xe2, 0xb8, 0x58, 0x69, 0xd8, 0x0c, 0x22, 0x26,
	0x2c, 0x49, 0x4c, 0x38, 0x0f, 0x65, 0x1a, 0xa4, 0x13, 0x97, 0x03, 0x69, 0x41, 0xfd, 0xb6, 0xc2,
	0xe9, 0xdb, 0x37, 0xc7, 0x26, 0x54, 0x4d, 0x2b, 0xd8, 0x96, 0xa8, 0x1b, 0x95, 0xa9, 0x8f, 0x6f,
	0x05, 0xdb, 0x77, 0xb4, 0x55, 0xe1, 0x42, 0xf1, 0x22, 0xbd, 0x7f, 0xae, 0x1b, 0x5b, 0x96, 0xb3,
	0x79, 0xd3, 0x35, 0xc5, 0x7e, 0x91, 0xab, 0x24, 0xda, 0x94, 0xf6, 0x64, 0x82, 0x72, 0x6a, 0x45,
	0x4c, 0x40, 0xfd, 0x66, 0xec, 0x58, 0x56, 0xc2, 0xb0, 0x75, 0xff, 0x67, 0x05, 0x50, 0xbf, 0x91,
	0x3b, 0x54, 0x5e, 0x0c, 0x92, 0x47, 0x82, 0xf8, 0x45, 0x89, 0xf8, 0x11, 0xb3, 0x52, 0x4b, 0xb2,
	0x24, 0x33, 0x2b, 0x35, 0x0b, 0x13, 0x72, 0xa0, 0xbc, 0x7f, 0x72, 0x20, 0xbd, 0x9b, 0x9e, 0x82,
	0x19, 0xb2, 0xd0, 0xec, 0x1f, 0x88, 0x46, 0x9c, 0xd3, 0xa9, 0x5f, 0x80, 0xd9, 0xb8, 0xf1, 0xb8,
	0x7f, 0xaa, 0x73, 0x06, 0xca, 0x84, 0x37, 0xb2, 0x05, 0xd4, 0x49, 0x77, 0x1a, 0x6b, 0xaf, 0xb6,
	0x61, 0x8e, 0x14, 0xe3, 0xbf, 0xf7, 0x19, 0xe7, 0x58, 0x51, 0x0e, 0x39, 0x15, 0x93, 0x21, 0x27,
	0xf5, 0x8b, 0x30, 0x9f, 0xec, 0x60, 0xdc, 0x29, 0x3e, 0x0b, 0x25, 0x32, 0x64, 0xee, 0x59, 0x67,
	0x98, 0x21, 0x6d, 0xae, 0x7e, 0xa8, 0xc0, 0x41, 0x52, 0x14, 0x7f, 0xda, 0x31, 0xce, 0xfc, 0x10,
	0x94, 0x3e, 0xef, 0x3a, 0x51, 0xb4, 0x9a, 0x3c, 0xa3, 0xfb, 0x89, 0xe2, 0x0d, 0xb6, 0xdb, 0x61,
	0xbc, 0xc7, 0xe8, 0xce, 0xa5, 0xfc, 0xbf, 0xd7, 0xa9, 0xb6, 0x7a, 0x81, 0x0d, 0x46, 0xfc, 0x65,
	0xc7, 0xa8, 0xc1, 0xf0, 0x7b, 0x3f, 0x85, 0xe8, 0xde, 0x8f, 0xfa, 0xc3, 0x22, 0x94, 0x68, 0xe0,
	0x61, 0xd0, 0x8d, 0x8b, 0x69, 0x28, 0x44, 0xad, 0x0b, 0x96, 0x39, 0x6c, 0x5d, 0xe4, 0x21, 0x96,
	0x12, 0x27, 0xd3, 0x22, 0xbf, 0xa2, 0x9c, 0xfc, 0xb7, 0x12, 0x4a, 0x80, 0x09, 0x89, 0x00, 0xf1,
	0x51, 0x6d, 0x45, 0x3e, 0xaa, 0x25, 0x12, 0x90, 0x6c, 0x46, 0xf6, 0x41, 0xb0, 0x9a, 0xc6, 0x0a,
	0xd1, 0x29, 0x41, 0x4d, 0x3a, 0x25, 0x90, 0x8f, 0xf8, 0x21, 0x79, 0xc4, 0x4f, 0xda, 0x5b, 0xae,
	0xc7, 0xfe, 0x2a, 0xa1, 0xa8, 0xd1, 0x67, 0xf4, 0x99, 0x41, 0x1f, 0x33, 0x9c, 0x1c, 0xe3, 0x63,
	0x86, 0x03, 0x3e, 0x65, 0xf8, 0xd6, 0xde, 0x9f, 0x32, 0x9c, 0x1a, 0xf7, 0x53, 0x86, 0x7b, 0x7c,
	0xc8, 0xf0, 0xf4, 0x0f, 0xe7, 0xa0, 0xb2, 0x44, 0xff, 0x69, 0x2e, 0x40, 0x7f, 0xa2, 0x40, 0x89,
	0xfe, 0x75, 0xca, 0xd3, 0x79, 0xff, 0x52, 0xad, 0x79, 0x2a, 0x07, 0x04, 0xdb, 0x74, 0xea, 0xea,
	0x97, 0x7f, 0xd0, 0x28, 0x54, 0x95, 0x2f, 0xff, 0xf5, 0xbf, 0xfe, 0x5a, 0xe1, 0x25, 0xf4, 0xc2,
	0x42, 0x3b, 0xf1, 0x3f, 0x74, 0x31, 0x96, 0x05, 0x8e, 0x65, 0x81, 0x33, 0x62, 0xb0, 0xf0, 0x1e,
	0x7f, 0x7a, 0x7f, 0xe1, 0x3d, 0xc2, 0x11, 0xef, 0xa3, 0xbf, 0x50, 0xa0, 0x2a, 0x36, 0x35, 0xfa,
	0xe4, 0x88, 0xcc, 0xd3, 0x81, 0x7f, 0x79, 0xd6, 0x7c, 0x36, 0x27, 0x14, 0x9f, 0xc4, 0x9a, 0x34,
	0x89, 0x65, 0x74, 0xe9, 0x2e, 0x26, 0xb1, 0xf0, 0x1e, 0xd9, 0x36, 0xef, 0xa3, 0xef, 0x28, 0x30,
	0xc1, 0xe4, 0x03, 0x3a, 0x3d, 0xe2, 0x48, 0x67, 0xc0, 0x3f, 0xff, 0x34, 0x1f, 0xec, 0x13, 0x5d,
	0xaf, 0xba, 0x96, 0x19, 0x8d, 0xf7, 0x86, 0x34, 0xde, 0x8b, 0xea, 0xdd, 0x10, 0xfd, 0x9c, 0x72,
	0x1c, 0x7d, 0x4f, 0x81, 0x09, 0x26, 0x3e, 0x46, 0x8c, 0x75, 0xe0, 0xdf, 0x02, 0x8d, 0x1a, 0x6b,
	0x82, 0xb6, 0xc7, 0xf7, 0x83, 0xb6, 0xdf, 0x57, 0x60, 0x82, 0xfd, 0x21, 0xd4, 0x88, 0xf1, 0x0e,
	0xfc, 0x33, 0xb7, 0x51, 0xe3, 0x5d, 0x97, 0xc6, 0x7b, 0xb5, 0xb9, 0x0f, 0xe3, 0x25, 0x24, 0xfe,
	0x4d, 0x05, 0x4a, 0x4b, 0xae, 0xb7, 0x8b, 0x46, 0x7d, 0xf4, 0xa9, 0xef, 0xaf, 0xaa, 0x46, 0x0d,
	0xf7, 0x82, 0x34, 0xdc, 0x67, 0x9a, 0xad, 0xd1, 0xc3, 0xd5, 0x0d, 0xea, 0x2f, 0x2f, 0x18, 0xae,
	0xb7, 0x4b, 0x86, 0xf6, 0x8f, 0x0a, 0x4c, 0x5d, 0x36, 0xad, 0x30, 0xfe, 0xba, 0xd5, 0xa9, 0xdc,
	0x7f, 0xcb, 0x36, 0x6a, 0x90, 0xef, 0x49, 0x83, 0x74, 0xd5, 0xb7, 0xc6, 0xa2, 0x69, 0xfc, 0xb7,
	0x3f, 0x8c, 0xae, 0xf4, 0xf9, 0xfd, 0x05, 0xf6, 0xd1, 0xe7, 0xae, 0xee, 0xf1, 0xea, 0xf7, 0xa3,
	0x09, 0x62, 0xd3, 0x0a, 0xc9, 0x04, 0xff, 0x46, 0x01, 0x20, 0x63, 0xe5, 0x77, 0xe0, 0x5a, 0xf9,
	0xfe, 0xe3, 0x6c, 0xd4, 0xd4, 0xde, 0x95, 0xa6, 0x66, 0xab, 0x9b, 0xfb, 0x39, 0x35, 0xfe, 0x5d,
	0xb9, 0xbd, 0xe6, 0xf5, 0x63, 0x05, 0x1a, 0x22, 0x77, 0xab, 0xef, 0x33, 0x21, 0x2f, 0xe6, 0xd3,
	0x5e, 0xc9, 0x14, 0xb0, 0x51, 0x73, 0x76, 0xa5, 0x39, 0x1b, 0xea, 0x1b, 0x63, 0xcd, 0x39, 0xd6,
	0x63, 0xfc, 0x9b, 0x82, 0xe9, 0x69, 0xfa, 0x7c, 0x4c, 0x64, 0xaa, 0x3f, 0x55, 0xa0, 0x79, 0xc7,
	0xf1, 0xf7, 0x9a, 0xec, 0xf9, 0x5c, 0x93, 0xed, 0xcb, 0x78, 0x1b, 0x35, 0x5d, 0x47, 0x9a, 0x6e,
	0xe7, 0xf8, 0x9b, 0xf7, 0x66, 0xba, 0xbd, 0x68, 0x7a, 0xe8, 0xbf, 0x15, 0x78, 0x70, 0xaf, 0x85,
	0x65, 0x5f, 0xac, 0x58, 0x1c, 0xc3, 0x72, 0xc8, 0x37, 0xe7, 0x50, 0x9a, 0xf3, 0x96, 0x6a, 0xec,
	0xcb, 0x9c, 0xd9, 0x1f, 0x07, 0x0d, 0x5b, 0xe7, 0xff, 0x51, 0xe0, 0xe8, 0xde, 0xeb, 0xcc, 0xe6,
	0xbe, 0x94, 0x7f, 0xee, 0xb9, 0x57, 0x3c, 0x90, 0x66, 0xbf, 0x79, 0x1c, 0xdf, 0xc3, 0xd9, 0xc7,
	0xcb, 0x7e, 0xfa, 0xa7, 0x25, 0x28, 0x13, 0x3b, 0x3c, 0x40, 0xbf, 0x2e, 0x2c, 0xb8, 0x13, 0x23,
	0x5d, 0x12, 0xc9, 0x21, 0x6c, 0x9e, 0xcc, 0xd8, 0x9a, 0x4f, 0xf2, 0x69, 0x69, 0x92, 0x8f, 0x20,
	0x35, 0x35, 0x49, 0xc3, 0x76, 0x7b, 0x66, 0x34, 0x3f, 0xea, 0xd9, 0xa1, 0xdf, 0x97, 0x0d, 0xb4,
	0xa7, 0x47, 0xf6, 0x96, 0xf2, 0x00, 0x47, 0x58, 0x97, 0x83, 0x5c, 0x3a, 0xf5, 0x8c, 0x34, 0xc6,
	0xa7, 0xd0, 0x93, 0xa3, 0xc7, 0x28, 0x6c, 0x84, 0x5f, 0x8a, 0xed, 0xaf, 0xd6, 0xc8, 0x6e, 0x13,
	0x8e, 0xdc, 0x28, 0xde, 0x78, 0x46, 0x1a, 0xd2, 0xe3, 0x6a, 0x06, 0xb2, 0x11, 0xc6, 0xfe, 0x7a,
	0x6c, 0x62, 0xb5, 0x32, 0x50, 0x41, 0x72, 0xe5, 0x46, 0x0d, 0xe7, 0x39, 0x69, 0x38, 0xc7, 0x8f,
	0x3f, 0x91, 0x85, 0x42, 0x3d, 0xcb, 0x7c, 0xff, 0xd2, 0x4b, 0xf0, 0x09, 0xc3, 0x95, 0xbe, 0x75,
	0xa2, 0x7b, 0xd6, 0x80, 0xf1, 0x5c, 0xaa, 0x33, 0xaf, 0x62, 0xcd, 0x77, 0x43, 0x77, 0x4d, 0xf9,
	0x4c, 0x85, 0xd7, 0x77, 0x26, 0xe8, 0xbd, 0xfb, 0x67, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0x7f,
	0x6c, 0xa0, 0x8a, 0xe0, 0x7a, 0x00, 0x00,
}
